{"version":3,"sources":["Home/Home.js","PathfindingVisualizer/Algorithms/PathfindAlgorithms.js","PathfindingVisualizer/Algorithms/MazeAlgorithms.js","PathfindingVisualizer/Menu/PathfindStats.js","PathfindingVisualizer/Grid/Node.js","PathfindingVisualizer/Menu/NodeKey.js","PathfindingVisualizer/Menu/PVisualizerSettings.js","PathfindingVisualizer/Menu/PathfindMenu.js","PathfindingVisualizer/PathfindingVisualizer.js","SortingVisualizer/Algorithms/SortAlgorithms.js","SortingVisualizer/Menu/SVisualizerSettings.js","SortingVisualizer/Menu/SortMenu.js","SortingVisualizer/SortingVisualizer.js","NavBar/NavBar.js","App.js","reportWebVitals.js","index.js"],"names":["Home","props","state","Card","CardHeader","href","CardBody","CardFooter","className","onClick","changeTab","React","Component","pathfindAlgorithms","heuristicTypes","getHeuristic","cur","start","target","heuristicType","dMultiplier","parseInt","document","getElementById","value","diagCost","Math","sqrt","rowDistance","abs","row","colDistance","col","startRowDistance","startColDistance","heuristic","min","getAllNodes","grid","nodes","node","push","getUnvisitedNeighbors","diagonalNeighbors","neighbors","isDiagonal","length","filter","neighbor","isVisited","mazeAlgorithms","recursiveDevision","rows","cols","walls","r","c","innerWalls","random","buildWalls","h","minC","maxC","minR","maxR","rGap","cGap","floor","addVWall","addHWall","holeMultiplier","numHoles","holes","i","hole","includes","max","PathfindStats","id","Node","nodeType","this","type","isStart","isTarget","costText","cost","onMouseDown","mousePressed","onMouseEnter","mouseEntered","onMouseLeave","mouseLeft","onAnimationEnd","animationEnded","NodeKey","element","drawMode","pathfinder","setDrawMode","keyNodePressed","keyAnimationEnded","getWeightCostText","PVisualizerSettings","curAlgorithm","curSpeed","mazeDropdownHidden","clearDropdownHidden","editDropdownHidden","algorithmDropdownHidden","pathfindDropdownHidden","style","backgroundColor","setState","setNewWeight","speed","hidden","animateMaze","clearGrid","clearWalls","clearWeights","clearPaths","resetStartTarget","changeDiagonalMovement","placeholder","onChange","changeWeightCost","visualizePathfind","onMouseUp","changeVisualizeSpeed","getCurrentAlgorithmText","PathfindMenu","ROW_COUNT","COL_COUNT","INIT_START","INIT_TARGET","nodeTypes","PathfindingVisualizer","weightCost","mouseIsDown","interactable","drawWall","drawWeight","startNode","targetNode","curRow","createNode","oldGrid","isWall","curVisual","previousNode","getNodeVisual","curStart","updateNodeVisual","curTarget","isWeight","isInstant","updateGridState","updateAlgorithmInfo","initStart","initTarget","drawStartNode","drawTargetNode","weight","mode","algorithm","softRebuildGrid","visitedNodes","unvisitedNodes","distance","Infinity","sort","a","b","curNode","shift","unvisitedNeighbors","neighborCost","tentativeDistance","dijkstra","startCost","finalCost","tentativeStartCost","aStar","breadthFirstSearch","pop","depthFirstSearch","shortestPath","nodesInShortestPath","currentNode","unshift","getShortestPathNodes","totalCost","getShortestPathCost","animateSearch","drawVisitedNode","animatePath","setTimeout","drawPathNode","pathNodes","innerHTML","maze","randomWallMaze","randomWeightMaze","rNum","randomWallWeightMaze","drawWeightNode","drawWallNode","rebuildGrid","isPreview","handleMouseUp","onContextMenu","e","preventDefault","onDragStart","Array","from","map","rowIdx","nodeIdx","handleMouseDown","handleMouseEnter","handleMouseLeft","handleAnimationEnd","UNSORTED","COMPARE","SORTED","SWAP","MIN","sortAlgorithms","mergeSort","array","animations","doMergeSort","middle","left","right","merge","splice","SVisualizerSettings","randomizeDropdownHidden","visualizeDropdownHidden","sorter","reGenerateArray","visualizeSort","SortMenu","SortingVisualizer","size","createBar","bars","getElementsByClassName","rebuildArray","newMin","k","temp","selectionSort","j","insertionSort","animateSort","step","action","height","bar","barIdx","DEFAULT_TAB","NavBar","curTab","navigateExpandHidden","tab","elements","display","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.d3af11e0.chunk.js","sourcesContent":["import React from 'react';\r\n\r\nimport { Card, CardHeader, CardBody, CardFooter\r\n} from 'reactstrap';\r\n\r\nimport './Home.css';\r\n\r\n/**\r\n * Represents the home tab component.\r\n * \r\n * @author Jake Waclawski\r\n */\r\nclass Home extends React.Component {\r\n    constructor (props) {\r\n        super(props);\r\n        this.state = {};\r\n    }\r\n\r\n    /**\r\n     * Renders the home tab component.\r\n     * \r\n     * @returns a <div> element representing the component\r\n     */\r\n    render () {\r\n        return (\r\n            <div>\r\n                <Card>\r\n                    <CardHeader>\r\n                        <h1>Algorithm Visualizer</h1>\r\n                        <h4>Jake Waclawski</h4>\r\n                        <a href=\"https://github.com/jmw3638/Pathfinder\">GitHub</a><br />\r\n                    </CardHeader>\r\n                    <CardBody>\r\n                        \r\n                    </CardBody>\r\n                    <CardFooter>\r\n                        <div className=\"home-visualizer-button\"\r\n                        onClick={() => this.props.changeTab(\"Pathfinding Visualizer\")}\r\n                        >Pathfinding Visualizer</div>\r\n                        <div className=\"home-visualizer-button\"\r\n                        onClick={() => this.props.changeTab(\"Sorting Visualizer\")}\r\n                        >Sorting Visualizer</div>\r\n                    </CardFooter>\r\n                </Card>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default Home;","// Pathfinding algorithms\r\nexport const pathfindAlgorithms = {\r\n    DIJKSTRA: \"Dijkstra\",\r\n    ASTAR: \"A* (A-Star)\",\r\n    BFS: \"Breadth First Search\",\r\n    DFS: \"Depth First Search\",\r\n};\r\n\r\n// Heuristic types\r\nexport const heuristicTypes = {\r\n    MANHATTAND: \"Manhattan Distance\",\r\n    DIAGONALD: \"Diagonal Distance\",\r\n    DIRECT: \"Direct Distance\", \r\n};\r\n\r\n/**\r\n * Executes a Dijkstra's algorithm search.\r\n * \r\n * @param {Array} grid grid of nodes\r\n * @param {Object} start start node\r\n * @param {Object} target target node\r\n * @param {boolean} diagonalNeighbors are we allowing diagonal neighbors\r\n * \r\n * @returns an array of visited nodes in order\r\n */\r\nexport function dijkstra(grid, start, target, diagonalNeighbors) {\r\n    const visitedNodes = [];\r\n    const unvisitedNodes = getAllNodes(grid);\r\n\r\n    for (const node of getAllNodes(grid)) node.distance = Infinity;\r\n    start.distance = 0;\r\n\r\n    while (unvisitedNodes.length !== 0) {\r\n        unvisitedNodes.sort((a, b) => a.distance - b.distance);\r\n        const curNode = unvisitedNodes.shift();\r\n\r\n        if (curNode.isVisited || curNode.isWall) continue;\r\n        if (curNode === target || curNode.distance === Infinity) return visitedNodes;\r\n\r\n        const unvisitedNeighbors = getUnvisitedNeighbors(curNode, grid, diagonalNeighbors);\r\n        for (const neighbor of unvisitedNeighbors) {\r\n            var neighborCost = neighbor.cost;\r\n\r\n            const diagCost = Math.sqrt(2) - 1;\r\n            if (neighbor.isDiagonal) neighborCost += diagCost;\r\n            neighbor.isDiagonal = false;\r\n\r\n            const tentativeDistance = curNode.distance + neighborCost;\r\n            if (neighbor.distance > tentativeDistance) {\r\n                neighbor.previousNode = curNode;\r\n                neighbor.distance = tentativeDistance;\r\n            }\r\n        }\r\n\r\n        curNode.isVisited = true;\r\n        visitedNodes.push(curNode);\r\n    }\r\n\r\n    return visitedNodes;\r\n}\r\n\r\n/**\r\n * Executes an A* (A-Star) algorithm search.\r\n * \r\n * @param {Array} grid grid of nodes\r\n * @param {Object} start start node\r\n * @param {Object} target target node\r\n * @param {boolean} diagonalNeighbors are we allowing diagonal neighbors\r\n * \r\n * @returns an array of visited nodes in order\r\n */\r\nexport function aStar(grid, start, target, diagonalNeighbors) {\r\n    const heuristicType = diagonalNeighbors ? heuristicTypes.DIAGONALD : heuristicTypes.MANHATTAND;\r\n    const visitedNodes = [];\r\n    const unvisitedNodes = [];\r\n\r\n    for (const node of getAllNodes(grid)) {\r\n        node.startCost = Infinity;\r\n        node.finalCost = Infinity;\r\n    }\r\n    start.startCost = 0;\r\n    start.finalCost = getHeuristic(start, start, target, heuristicType);\r\n    unvisitedNodes.push(start);\r\n\r\n    while (unvisitedNodes.length !== 0) {\r\n        unvisitedNodes.sort((a, b) => a.finalCost - b.finalCost);\r\n        const curNode = unvisitedNodes.shift();\r\n\r\n        if (curNode.isVisited || curNode.isWall) continue;\r\n        if (curNode === target) return visitedNodes;\r\n\r\n        const unvisitedNeighbors = getUnvisitedNeighbors(curNode, grid, diagonalNeighbors);\r\n        for (const neighbor of unvisitedNeighbors) {\r\n            var neighborCost = neighbor.cost\r\n            const diagCost = Math.sqrt(2) - 1;\r\n            if (neighbor.isDiagonal) neighborCost += diagCost;\r\n            neighbor.isDiagonal = false;\r\n            \r\n            const tentativeStartCost = curNode.startCost + neighborCost;\r\n            \r\n            if (tentativeStartCost < neighbor.startCost) {\r\n                neighbor.previousNode = curNode;\r\n\r\n                neighbor.startCost = tentativeStartCost;\r\n                neighbor.finalCost = neighbor.startCost + getHeuristic(neighbor, start, target, heuristicType);\r\n\r\n                if (!unvisitedNodes.includes(neighbor)) unvisitedNodes.push(neighbor);\r\n            }\r\n        }\r\n\r\n        curNode.isVisited = true;\r\n        visitedNodes.push(curNode);\r\n    }\r\n\r\n    return visitedNodes;\r\n}\r\n\r\n/**\r\n * Executes Breadth First Search (BFS) algorithm search.\r\n * \r\n * @param {Array} grid grid of nodes\r\n * @param {Object} start start node\r\n * @param {Object} target target node\r\n * @param {boolean} diagonalNeighbors are we allowing diagonal neighbors\r\n * \r\n * @returns an array of visited nodes in order\r\n */\r\nexport function breadthFirstSearch(grid, start, target, diagonalNeighbors) {\r\n    const visitedNodes = [];\r\n    const unvisitedNodes = [start];\r\n    start.distance = 0;\r\n   \r\n    while (unvisitedNodes.length !== 0) {\r\n        const curNode = unvisitedNodes.shift();\r\n\r\n        if (curNode.isVisited || curNode.isWall) continue;\r\n        if (curNode === target || curNode.distance === Infinity) return visitedNodes; \r\n\r\n        const unvisitedNeighbors = getUnvisitedNeighbors(curNode, grid, diagonalNeighbors);\r\n        for (const neighbor of unvisitedNeighbors) {\r\n            unvisitedNodes.push(neighbor);\r\n            neighbor.previousNode = curNode;\r\n            neighbor.distance = curNode.distance + 1;\r\n        }\r\n\r\n        curNode.isVisited = true;\r\n        visitedNodes.push(curNode);\r\n    }\r\n    return visitedNodes;\r\n}\r\n\r\n/**\r\n * Executes a Depth First Search (DFS) algorithm search.\r\n * \r\n * @param {Array} grid grid of nodes\r\n * @param {Object} start start node\r\n * @param {Object} target target node\r\n * @param {boolean} diagonalNeighbors are we allowing diagonal neighbors\r\n * \r\n * @returns an array of visited nodes in order\r\n */\r\nexport function depthFirstSearch(grid, start, target, diagonalNeighbors) {\r\n    const visitedNodes = [];\r\n    const unvisitedNodes = [start];\r\n    \r\n    while (unvisitedNodes.length !== 0) {\r\n        const curNode = unvisitedNodes.pop();\r\n\r\n        if (curNode.isWall || curNode.isVisited) continue;\r\n        if (curNode === target) return visitedNodes;\r\n\r\n        const unvisitedNeighbors = getUnvisitedNeighbors(curNode, grid, diagonalNeighbors);\r\n        for (const neighbor of unvisitedNeighbors) {\r\n            unvisitedNodes.push(neighbor);\r\n            neighbor.previousNode = curNode;\r\n        }\r\n\r\n        curNode.isVisited = true;\r\n        visitedNodes.push(curNode);\r\n    }\r\n    return visitedNodes;\r\n}\r\n\r\n/**\r\n * Gets the estimated move cost between the current node and the target node.\r\n * \r\n * @param {Object} cur current node\r\n * @param {Object} start start node\r\n * @param {Object} target target node\r\n * @param {int} heuristicType heuristic to use\r\n */\r\nfunction getHeuristic(cur, start, target, heuristicType) {\r\n    let dMultiplier = parseInt(document.getElementById(\"ns-dmultiplier\").value);\r\n    if (!dMultiplier) dMultiplier = 1;\r\n\r\n    const diagCost = Math.sqrt(2);\r\n\r\n    const rowDistance = Math.abs(target.row - cur.row);\r\n    const colDistance = Math.abs(target.col - cur.col);\r\n\r\n    const startRowDistance = Math.abs(target.row - start.row);\r\n    const startColDistance = Math.abs(target.col - start.col);\r\n\r\n    let heuristic = 0;\r\n\r\n    switch (heuristicType) {\r\n        case heuristicTypes.MANHATTAND:\r\n            heuristic = dMultiplier * (rowDistance + colDistance);\r\n            break;\r\n        case heuristicTypes.DIAGONALD:\r\n            heuristic = dMultiplier * (rowDistance + colDistance) + (diagCost - 2 * dMultiplier) * Math.min(rowDistance, colDistance);\r\n            break;\r\n        case heuristicTypes.DIRECT:\r\n            heuristic = Math.sqrt(rowDistance**2 + colDistance**2);\r\n            break;\r\n        default:\r\n            return;\r\n    }\r\n\r\n    // In the case of multiple shortest paths, prioritizes nodes closer to the\r\n    // direct, 'as the crow flies', path between the start node and the target node.\r\n    const cross = Math.abs(colDistance * startRowDistance - startColDistance * rowDistance);\r\n    heuristic += (cross * 0.001);\r\n\r\n    return heuristic;\r\n}\r\n\r\n/**\r\n * Gets all of the nodes in the grid.\r\n * \r\n * @param {Array} grid grid of nodes\r\n * \r\n * @returns an array containing all of the nodes\r\n */\r\nfunction getAllNodes(grid) {\r\n    const nodes = [];\r\n    for (const row of grid) {\r\n        for (const node of row) nodes.push(node);\r\n    }\r\n    return nodes;\r\n}\r\n\r\n/**\r\n * Gets the shortest path of nodes from the target node to \r\n * the start node.\r\n * \r\n * @param {Object} targetNode target node\r\n * \r\n * @returns an array of shortest path nodes in order\r\n */\r\nexport function getShortestPathNodes(targetNode) {\r\n    const nodesInShortestPath = [];\r\n    let currentNode = targetNode;\r\n    while (currentNode !== null) {\r\n        nodesInShortestPath.unshift(currentNode);\r\n        currentNode = currentNode.previousNode;\r\n    }\r\n    return nodesInShortestPath;\r\n}\r\n\r\n/**\r\n * Gets the total weighted cost of the shortest path.\r\n * \r\n * @param {Object} targetNode target node\r\n * \r\n * @returns the total cost\r\n */\r\nexport function getShortestPathCost(targetNode) {\r\n    const nodesInShortestPath = [];\r\n    let currentNode = targetNode;\r\n    let totalCost = 0;\r\n    while (currentNode !== null) {\r\n        nodesInShortestPath.unshift(currentNode);\r\n        totalCost += currentNode.cost;\r\n        currentNode = currentNode.previousNode;\r\n    }\r\n    return totalCost;\r\n}\r\n\r\n/**\r\n * Gets all unvisited neighbors of a given node.\r\n * \r\n * @param {Object} node node\r\n * @param {Array} grid grid of nodes\r\n * @param {boolean} diagonalNeighbors are we allowing diagonal neighbors\r\n * \r\n * @returns an array containing all unvisited neighbors\r\n */\r\nfunction getUnvisitedNeighbors(node, grid, diagonalNeighbors) {\r\n    const neighbors = [];\r\n    const {row, col} = node;\r\n    \r\n    if (diagonalNeighbors && row > 0 && col > 0) {\r\n        neighbors.push(grid[row - 1][col - 1]); // North West    \r\n        grid[row - 1][col - 1].isDiagonal = true;;\r\n    }\r\n\r\n    if (col > 0) neighbors.push(grid[row][col - 1]); // West\r\n\r\n    if (diagonalNeighbors && row < grid.length - 1 && col > 0) {\r\n        neighbors.push(grid[row + 1][col - 1]); // South West\r\n        grid[row + 1][col - 1].isDiagonal = true;;\r\n    }\r\n\r\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]); // South\r\n\r\n    if (diagonalNeighbors && row < grid.length - 1 && col < grid[row].length - 1) {\r\n        neighbors.push(grid[row + 1][col + 1]); // South East\r\n        grid[row + 1][col + 1].isDiagonal = true;;\r\n    }\r\n\r\n    if (col < grid[row].length - 1) neighbors.push(grid[row][col + 1]); // East\r\n\r\n    if (diagonalNeighbors && row > 0 && col < grid[row].length - 1) {\r\n        neighbors.push(grid[row - 1][col + 1]); // North East\r\n        grid[row - 1][col + 1].isDiagonal = true;;\r\n    }\r\n\r\n    if (row > 0) neighbors.push(grid[row - 1][col]); // North\r\n\r\n    return neighbors.filter(neighbor => !neighbor.isVisited);\r\n}","// Maze algorithms\r\nexport const mazeAlgorithms = {\r\n    RECURSIVE_DEVISION: \"Recursive Devision\",\r\n    RANDOM_WALL: \"Random Wall\",\r\n    RANDOM_WEIGHT: \"Random Weight\",\r\n    RANDOM_WALL_WEIGHT: \"Random Wall/Weight\"\r\n}\r\n\r\n/**\r\n * Algorithm for generating a random wall maze.\r\n * \r\n * @param {int} rows number of rows\r\n * @param {int} cols number of columns\r\n * \r\n * @returns a grid of boolean values, true if wall node\r\n */\r\nexport function randomWallMaze(rows, cols) {\r\n    var walls = []\r\n\r\n    for (let r = 0; r < rows; r++) {\r\n        for (let c = 0; c < cols; c++) {\r\n            const rNum = random(1, 10);\r\n            if (rNum <= 3) walls.push([r, c]);\r\n        }\r\n    }\r\n\r\n    return walls;\r\n}\r\n\r\n/**\r\n * Algorithm for generating a random weight maze.\r\n * \r\n * @param {int} rows number of rows\r\n * @param {int} cols number of columns\r\n * \r\n * @returns a grid of boolean values, true if wall node\r\n */\r\nexport function randomWeightMaze(rows, cols) {\r\n    var walls = []\r\n\r\n    for (let r = 0; r < rows; r++) {\r\n        for (let c = 0; c < cols; c++) {\r\n            const rNum = random(1, 10);\r\n            if (rNum <= 3) walls.push([r, c, true]);\r\n        }\r\n    }\r\n\r\n    return walls;\r\n}\r\n\r\n/**\r\n * Algorithm for generating a random wall/weight maze.\r\n * \r\n * @param {int} rows number of rows\r\n * @param {int} cols number of columns\r\n * \r\n * @returns a grid of boolean values, true if wall node\r\n */\r\nexport function randomWallWeightMaze(rows, cols) {\r\n    var walls = []\r\n\r\n    for (let r = 0; r < rows; r++) {\r\n        for (let c = 0; c < cols; c++) {\r\n            const rNum = random(1, 10);\r\n            if (rNum <= 2) walls.push([r, c]);\r\n            if (rNum >= 8) walls.push([r, c, true]);\r\n        }\r\n    }\r\n\r\n    return walls;\r\n}\r\n\r\n/**\r\n * Algorithm for generating a maze using recursive devision.\r\n * \r\n * @param {int} rows number of rows\r\n * @param {int} cols number of columns\r\n * \r\n * @returns a grid of boolean values, true if wall node\r\n */\r\nexport function recursiveDevision(rows, cols) {\r\n    var walls = [];\r\n\r\n    //walls = innerWalls(walls, true, 0, cols-1, 0, rows-1);\r\n    walls = buildWalls(walls, rows, cols);\r\n    \r\n    return walls;\r\n}\r\n\r\n/**\r\n * Creates walls around the border of the maze.\r\n * \r\n * @param {Array} walls grid of walls\r\n * @param {int} rows amount of rows \r\n * @param {int} cols amount of columns\r\n * \r\n * @returns a grid of walls\r\n */\r\nfunction buildWalls(walls, rows, cols) {\r\n    for (var r = 0; r < rows; r++) {\r\n        if (r === 0 || r === (rows-1)) {\r\n            for (var c = 0; c < cols; c++) {\r\n                walls.push([r, c]);\r\n            }\r\n        } else {\r\n            walls.push([r, 0]);\r\n            walls.push([r, cols-1]);\r\n        }\r\n    }\r\n\r\n    walls = innerWalls(walls, random(0, 1), 1, cols-2, 1, rows-2);\r\n    return walls;\r\n}\r\n\r\n/**\r\n * Recursive function that builds the inner walls of the maze.\r\n * \r\n * @param {Array} walls grid of walls\r\n * @param {boolean} h is horizontal wall\r\n * @param {int} minC lower column bound\r\n * @param {int} maxC upper column bound\r\n * @param {int} minR lower row bound\r\n * @param {int} maxR upper row bound\r\n * \r\n * @returns a grid of walls\r\n */\r\nfunction innerWalls(walls, h, minC, maxC, minR, maxR) {\r\n    const rGap = maxR - minR;\r\n    const cGap = maxC - minC;\r\n\r\n    if (maxR - minR <= 1) return walls; \r\n    if (maxC - minC <= 1) return walls; \r\n\r\n    var r = Math.floor(random(minR+1, maxR-1)/2)*2;\r\n    var c = Math.floor(random(minC+1, maxC-1)/2)*2;\r\n\r\n    // ^ xor: one or the other but not both\r\n    if (rGap <= 5 ^ cGap<= 5) {\r\n        if (rGap <= 5) {\r\n            walls = addVWall(walls, minR, maxR, c);\r\n\r\n            walls = innerWalls(walls, !h, minC, c-1, minR, maxR);\r\n            walls = innerWalls(walls, !h, c+1, maxC, minR, maxR);\r\n        }\r\n        if (cGap <= 5) {\r\n            walls = addHWall(walls, minC, maxC, r);\r\n    \r\n            walls = innerWalls(walls, !h, minC, maxC, minR, r-1);\r\n            walls = innerWalls(walls, !h, minC, maxC, r+1, maxR);\r\n        }\r\n        return walls;\r\n    } \r\n    if (h) {\r\n        walls = addHWall(walls, minC, maxC, r);\r\n\r\n        walls = innerWalls(walls, !h, minC, maxC, minR, r-1);\r\n        walls = innerWalls(walls, !h, minC, maxC, r+1, maxR);\r\n    } else {\r\n        walls = addVWall(walls, minR, maxR, c);\r\n\r\n        walls = innerWalls(walls, !h, minC, c-1, minR, maxR);\r\n        walls = innerWalls(walls, !h, c+1, maxC, minR, maxR);\r\n    }\r\n    return walls;\r\n}\r\n\r\n/**\r\n * Builds a horizontal wall at a given row.\r\n * \r\n * @param {Array} walls grid of walls\r\n * @param {int} minC lower column bound\r\n * @param {int} maxC upper column bound\r\n * @param {int} r row\r\n */\r\nfunction addHWall(walls, minC, maxC, r) {\r\n    let holeMultiplier = parseInt(document.getElementById(\"ns-holeamount\").value);\r\n    if (!holeMultiplier) holeMultiplier = 8;\r\n\r\n    const numHoles = random(1, (maxC - minC) / holeMultiplier);\r\n    const holes = [];\r\n    for (let i = 0; i < numHoles; i++) {\r\n        const hole = Math.floor(random(minC, maxC)/2)*2+1;\r\n        holes.push(hole);\r\n    }\r\n\r\n    for (var i = minC; i <= maxC; i++) if (!holes.includes(i)) walls.push([r, i]); \r\n    return walls;\r\n}\r\n\r\n/**\r\n * Builds a vertical wall at a given column.\r\n * \r\n * @param {Array} walls grid of walls\r\n * @param {int} minR lower row bound\r\n * @param {int} maxR upper row bound\r\n * @param {int} c column \r\n */\r\nfunction addVWall(walls, minR, maxR, c) {\r\n    let holeMultiplier = parseInt(document.getElementById(\"ns-holeamount\").value);\r\n    if (!holeMultiplier) holeMultiplier = 8;\r\n\r\n    const numHoles = random(1, (maxR - minR) / holeMultiplier);\r\n    const holes = [];\r\n    for (let i = 0; i < numHoles; i++) {\r\n        const hole = Math.floor(random(minR, maxR)/2)*2+1;\r\n        holes.push(hole);\r\n    }\r\n\r\n    for (var i = minR; i <= maxR; i++) if (!holes.includes(i)) walls.push([i, c]); \r\n    return walls;\r\n}\r\n\r\n/**\r\n * Generates a random integer between two given values.\r\n * \r\n * @param {int} min minimum value\r\n * @param {int} max maximum value \r\n * \r\n * @returns the generated integer\r\n */\r\nfunction random(min, max) { return Math.floor(Math.random() * (max - min + 1) + min); }","import React from 'react';\r\n\r\n/**\r\n * Represents the algorithm stats text above the grid of the pathfinding\r\n * visualizer component.\r\n * \r\n * @author Jake Waclawski\r\n */\r\nclass PathfindStats extends React.Component {\r\n    constructor (props) {\r\n        super(props);\r\n        this.state = {};\r\n    }\r\n\r\n    /**\r\n     * Renders the algorithm stats component.\r\n     * \r\n     * @returns a <div> element representing the stats text\r\n     */\r\n    render () {\r\n\r\n        return (\r\n            <div className=\"pv-stats\">\r\n                <div className=\"pv-stats-item\">\r\n                    <div>Visited Nodes:</div>\r\n                    <div id=\"pv-stats-visited\" className=\"pv-stats-text\">0</div>\r\n                </div>\r\n                <div className=\"pv-stats-item\">\r\n                    <div>Path Nodes:</div>\r\n                    <div id=\"pv-stats-path\" className=\"pv-stats-text\">0</div>\r\n                </div>\r\n                <div className=\"pv-stats-item\">\r\n                    <div>Path Cost:</div>\r\n                    <div id=\"pv-stats-weighted\" className=\"pv-stats-text\">0</div>\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default PathfindStats;","import React from 'react';\r\n\r\nimport './Node.css';\r\n\r\n/**\r\n * Represents a grid node on the screen. Extra class names\r\n * can be applied to change the appearance of the node.\r\n * \r\n * @author Jake Waclawski\r\n */\r\nclass Node extends React.Component {\r\n    constructor (props) {\r\n        super(props);\r\n        this.state = {};\r\n    }\r\n\r\n    /**\r\n     * Renders the node.\r\n     * \r\n     * @returns a <div> element representing the node\r\n     */\r\n    render () {\r\n        const nodeType = this.props.type ? this.props.type :\r\n        this.props.isStart ? 'start' : \r\n        this.props.isTarget ? 'target' : \r\n        '';\r\n\r\n        const costText = this.props.cost === 1 ? '' : this.props.cost;\r\n\r\n        return (\r\n            <div \r\n            id={`node-${this.props.row}-${this.props.col}`} \r\n            className={`node ${nodeType}`}\r\n            onMouseDown={() => this.props.mousePressed(this.props.row, this.props.col)}\r\n            onMouseEnter={() => this.props.mouseEntered(this.props.row, this.props.col)}\r\n            onMouseLeave={() => this.props.mouseLeft(this.props.row, this.props.col)}\r\n            onAnimationEnd={() => this.props.animationEnded(nodeType)}\r\n            >{costText}</div> \r\n        );\r\n    }\r\n}\r\n\r\nexport default Node;","import React from 'react';\r\n\r\nimport Node from '../Grid/Node';\r\n\r\n/**\r\n * Represents the node key in the menu.\r\n * \r\n * @author Jake Waclawski\r\n */\r\nclass NodeKey extends React.Component {\r\n    constructor (props) {\r\n        super(props);\r\n        this.state = {};\r\n    }\r\n\r\n    /**\r\n     * Gets the current weigth cost.\r\n     * \r\n     * @returns the weight cost\r\n     */\r\n    getWeightCostText () {\r\n        let element = document.getElementById(\"ns-weightcost\");\r\n        if (element === null || (!element.value && element.value !== 0)) return \"5\";\r\n        return element.value;\r\n    }\r\n\r\n    /**\r\n     * Runs the animation for the pressed node. Sets the appropriate draw mode.\r\n     * \r\n     * @param {string} id element id\r\n     * @param {string} className class name to set\r\n     * @param {int} drawMode draw mode to set\r\n     */\r\n    keyNodePressed (id, className, drawMode) {\r\n        document.getElementById(`node-${id}`).className = className;\r\n        if (drawMode || drawMode === 0) this.props.pathfinder.setDrawMode(drawMode);\r\n    }\r\n\r\n    /**\r\n     * Reverts the node state to the instant version.\r\n     * \r\n     * @param {string} id node element id\r\n     * @param {string} className class name to set\r\n     */\r\n    keyAnimationEnded (id, className) { document.getElementById(`node-${id}`).className = `node ${className}`; }\r\n\r\n    /**\r\n     * Renders the key component.\r\n     * \r\n     * @returns a <div> element representing the key\r\n     */\r\n    render () {\r\n\r\n        return (\r\n            <div className=\"pv-key\">\r\n                <div className=\"pv-key-item\" onClick={() => this.keyNodePressed(\"start-instant\", \"node start\", 3)}>\r\n                    <div className=\"pv-key-node\">\r\n                        <Node type={\"start-instant\"}\r\n                        row={\"start\"}\r\n                        col={\"instant\"}\r\n                        animationEnded={(type) => this.keyAnimationEnded(type, type)}\r\n                        mousePressed={() => null} mouseEntered={() => null} mouseLeft={() => null} />\r\n                    </div>\r\n                    <div id='start-text' className=\"pv-key-text\">Start Node</div>\r\n                </div>\r\n                <div className=\"pv-key-item\" onClick={() => this.keyNodePressed(\"target-instant\", \"node target\", 4)}>\r\n                    <div className=\"pv-key-node\">\r\n                        <Node type={\"target-instant\"}\r\n                        row={\"target\"}\r\n                        col={\"instant\"}\r\n                        animationEnded={(type) => this.keyAnimationEnded(type, type)}\r\n                        mousePressed={() => null} mouseEntered={() => null} mouseLeft={() => null} />\r\n                    </div>\r\n                    <div className=\"pv-key-text\">Target Node</div>\r\n                </div>\r\n                <div className=\"pv-key-item\" onClick={() => this.keyNodePressed(\"weight-instant\", \"node weight\", 2)}>\r\n                    <div className=\"pv-key-node\">\r\n                        <Node type={\"weight-instant\"}\r\n                        row={\"weight\"}\r\n                        col={\"instant\"}             \r\n                        cost={this.getWeightCostText()}              \r\n                        animationEnded={(type) => this.keyAnimationEnded(type, type)}\r\n                        mousePressed={() => null} mouseEntered={() => null} mouseLeft={() => null} />\r\n                    </div>\r\n                    <div className=\"pv-key-text\">Weighted Node</div>\r\n                </div>\r\n                <div className=\"pv-key-item\" onClick={() => this.keyNodePressed(\"wall-instant\", \"node wall\", 1)}>\r\n                    <div className=\"pv-key-node\">\r\n                        <Node type={\"wall-instant\"}\r\n                        row={\"wall\"}\r\n                        col={\"instant\"}\r\n                        animationEnded={(type) => this.keyAnimationEnded(type, type)}\r\n                        mousePressed={() => null} mouseEntered={() => null} mouseLeft={() => null} />\r\n                    </div>\r\n                    <div className=\"pv-key-text\">Wall Node</div>\r\n                </div>\r\n                <div className=\"pv-key-item\" onClick={() => this.keyNodePressed(\"unvisited-instant\", \"node node-animated\", 0)}>\r\n                    <div className=\"pv-key-node\">\r\n                        <Node type={\"unvisited-instant\"}\r\n                        row={\"unvisited\"}\r\n                        col={\"instant\"}\r\n                        animationEnded={(type) => this.keyAnimationEnded(type, \"node\")}\r\n                        mousePressed={() => null} mouseEntered={() => null} mouseLeft={() => null} />\r\n                    </div>\r\n                    <div className=\"pv-key-text\">Unvisited Node</div>\r\n                </div>\r\n                <div className=\"pv-key-item\">\r\n                    <div className=\"pv-key-node\" onClick={() => this.keyNodePressed(\"visited-instant\", \"node visited\")}>\r\n                        <Node type={\"visited-instant\"}\r\n                        row={\"visited\"}\r\n                        col={\"instant\"}\r\n                        animationEnded={(type) => this.keyAnimationEnded(type, type)}\r\n                        mousePressed={() => null} mouseEntered={() => null} mouseLeft={() => null} />\r\n                    </div>\r\n                    <div className=\"pv-key-node\" onClick={() => this.keyNodePressed(\"visited-weight-instant\", \"node visited-weight\")}>\r\n                        <Node type={\"visited-weight-instant\"}\r\n                        row={\"visited-weight\"}\r\n                        col={\"instant\"}\r\n                        animationEnded={(type) => this.keyAnimationEnded(type, type)}\r\n                        mousePressed={() => null} mouseEntered={() => null} mouseLeft={() => null} />         \r\n                    </div>\r\n                    <div className=\"pv-key-text\">Visited Nodes</div>\r\n                </div>\r\n                <div className=\"pv-key-item\">\r\n                    <div className=\"pv-key-node\" onClick={() => this.keyNodePressed(\"path-instant\", \"node path\")}>\r\n                        <Node type={\"path-instant\"}\r\n                        row={\"path\"}\r\n                        col={\"instant\"}\r\n                        animationEnded={(type) => this.keyAnimationEnded(type, type)}\r\n                        mousePressed={() => null} mouseEntered={() => null} mouseLeft={() => null} />\r\n                    </div>\r\n                    <div className=\"pv-key-node\" onClick={() => this.keyNodePressed(\"path-weight-instant\", \"node path-weight\")}>\r\n                        <Node type={\"path-weight-instant\"}\r\n                        row={\"path-weight\"}\r\n                        col={\"instant\"}\r\n                        animationEnded={(type) => this.keyAnimationEnded(type, type)}\r\n                        mousePressed={() => null} mouseEntered={() => null} mouseLeft={() => null} />\r\n                    </div>\r\n                    <div className=\"pv-key-text\">Path Nodes</div>\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default NodeKey;","import React from 'react';\r\n\r\nimport { pathfindAlgorithms } from '../Algorithms/PathfindAlgorithms';\r\nimport { mazeAlgorithms } from '../Algorithms/MazeAlgorithms';\r\n\r\n/**\r\n * Represents the settings bar in the menu of the pathfinding visualizer\r\n * component.\r\n * \r\n * @author Jake Waclawski\r\n */\r\nclass PVisualizerSettings extends React.Component {\r\n    constructor (props) {\r\n        super(props);\r\n        this.state = {\r\n            // Currently selected pathfinding algorithm\r\n            curAlgorithm: null,\r\n            // Are we allowing diagonal neighbor nodes?\r\n            diagonalNeighbors: false,\r\n            // Current path animation speed\r\n            curSpeed: 15,\r\n            // Is the maze button dropdown open?\r\n            mazeDropdownHidden: true,\r\n            // Is the clear button dropdown open?\r\n            clearDropdownHidden: true,\r\n            // Is the edit button dropdown open?\r\n            editDropdownHidden: true,\r\n            // Is the algorithm button dropdown open?\r\n            algorithmDropdownHidden: true,\r\n            // Is the pathfind button dropdown open?\r\n            pathfindDropdownHidden: true,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets the current algorithm for the information text as a string.\r\n     * \r\n     * @returns the string\r\n     */\r\n    getCurrentAlgorithmText () {\r\n        if (!this.state.curAlgorithm) return \"Select an Algorithm\";\r\n        return this.state.curAlgorithm;\r\n    }\r\n\r\n    /**\r\n     * Changes the current diagonal node neighbor setting.\r\n     */\r\n    changeDiagonalMovement () {\r\n        document.getElementById(\"diagmove-bool\").style.backgroundColor = !this.state.diagonalNeighbors ? \"rgb(100, 255, 100)\" : \"rgb(255, 100, 100)\";\r\n        this.setState({diagonalNeighbors: !this.state.diagonalNeighbors});\r\n    }\r\n\r\n    /**\r\n     * Updates the pathfinder with the current diagonal node neighbor setting.\r\n     */\r\n    changeWeightCost () {\r\n        let cost = document.getElementById(\"ns-weightcost\").value;\r\n        if (!cost && cost !== 0) cost = 5;\r\n\r\n        this.props.pathfinder.setNewWeight(parseInt(cost));\r\n    }\r\n\r\n    /**\r\n     * Updates the currently selected animation speed option.\r\n     * \r\n     * @param {string} id element id\r\n     * @param {int} speed new speed\r\n     */\r\n    changeVisualizeSpeed (id, speed) {\r\n        this.setState({curSpeed: speed});\r\n\r\n        document.getElementById(\"vslow-bool\").style.backgroundColor = \"rgb(255, 100, 100)\";\r\n        document.getElementById(\"slow-bool\").style.backgroundColor = \"rgb(255, 100, 100)\";\r\n        document.getElementById(\"fast-bool\").style.backgroundColor = \"rgb(255, 100, 100)\";\r\n        document.getElementById(\"vfast-bool\").style.backgroundColor = \"rgb(255, 100, 100)\";\r\n        document.getElementById(\"instant-bool\").style.backgroundColor = \"rgb(255, 100, 100)\";\r\n        \r\n        document.getElementById(id).style.backgroundColor = \"rgb(100, 255, 100)\";\r\n    }\r\n\r\n    /**\r\n     * Renders the settings bar component.\r\n     * \r\n     * @returns a <div> element representing the settings bar\r\n     */\r\n    render () {\r\n\r\n        return (\r\n            <div className=\"pv-menu-bar\">\r\n                <div className=\"maze-dropdown dropdown-animate\">\r\n                    <div className=\"pv-menu-bar-button\" \r\n                    onMouseEnter={() => this.setState({mazeDropdownHidden: false})}>\r\n                    <span>Maze</span></div>\r\n                    <div className=\"pv-menu-dropdown-content maze-drop-content dropdown-animate\"\r\n                    hidden={this.state.mazeDropdownHidden}\r\n                    onClick={() => this.setState({mazeDropdownHidden: true})}>\r\n                        <div className=\"pv-menu-dropdown-content-item\"\r\n                        onClick={() => this.props.pathfinder.animateMaze(mazeAlgorithms.RECURSIVE_DEVISION)}\r\n                        >Recursive Devision</div>\r\n                        <div className=\"pv-menu-dropdown-content-item\"\r\n                        onClick={() => this.props.pathfinder.animateMaze(mazeAlgorithms.RANDOM_WALL)}\r\n                        >Random Wall</div>\r\n                        <div className=\"pv-menu-dropdown-content-item\"\r\n                        onClick={() => this.props.pathfinder.animateMaze(mazeAlgorithms.RANDOM_WEIGHT)}\r\n                        >Random Weight</div>\r\n                        <div className=\"pv-menu-dropdown-content-item\"\r\n                        onClick={() => this.props.pathfinder.animateMaze(mazeAlgorithms.RANDOM_WALL_WEIGHT)}\r\n                        >Random Wall/Weight</div>\r\n                    </div>\r\n                </div>\r\n                <div className=\"clear-dropdown dropdown-animate\">\r\n                    <div className=\"pv-menu-bar-button\" \r\n                    onClick={() => this.props.pathfinder.clearGrid()}\r\n                    onMouseEnter={() => this.setState({clearDropdownHidden: false})}>\r\n                    <span>Clear</span></div>\r\n                    <div className=\"pv-menu-dropdown-content clear-drop-content dropdown-animate\"\r\n                    hidden={this.state.clearDropdownHidden} \r\n                    onClick={() => this.setState({clearDropdownHidden: true})}>\r\n                        <div className=\"pv-menu-dropdown-content-item\"\r\n                        onClick={() => this.props.pathfinder.clearWalls()}\r\n                        >Clear Walls</div>\r\n                        <div className=\"pv-menu-dropdown-content-item\"\r\n                        onClick={() => this.props.pathfinder.clearWeights()}\r\n                        >Clear Weights</div>\r\n                        <div className=\"pv-menu-dropdown-content-item\"\r\n                        onClick={() => this.props.pathfinder.clearPaths()}\r\n                        >Clear Path</div>\r\n                        <div className=\"pv-menu-dropdown-content-item\"\r\n                        onClick={() => this.props.pathfinder.resetStartTarget()}\r\n                        >Reset Start/Target</div>\r\n                    </div>\r\n                </div>\r\n                <div className=\"edit-dropdown dropdown-animate\">\r\n                    <div className=\"pv-menu-bar-button\" \r\n                    onMouseEnter={() => this.setState({editDropdownHidden: false})}>\r\n                    <span>Edit</span></div>\r\n                    <div className=\"pv-menu-dropdown-content edit-drop-content dropdown-animate\"\r\n                    hidden={this.state.editDropdownHidden} >\r\n                        <div className=\"pv-menu-dropdown-content-item\"\r\n                        onClick={() => this.changeDiagonalMovement()}>\r\n                            <div id=\"diagmove-bool\" className=\"bool-setting\" />\r\n                        Diagonal Movement</div>\r\n                        <div className=\"pv-menu-dropdown-content-item\">\r\n                            <input id=\"ns-dmultiplier\" className=\"number-setting\" placeholder=\"A* Multiplier\" type=\"number\" />\r\n                        </div>\r\n                        <div className=\"pv-menu-dropdown-content-item\">\r\n                            <input id=\"ns-weightcost\" className=\"number-setting\" onChange={() => this.changeWeightCost()} placeholder=\"Weight Cost\" type=\"number\" min=\"0\" max=\"999\" />\r\n                        </div>\r\n                        <div className=\"pv-menu-dropdown-content-item\">\r\n                            <input id=\"ns-holeamount\" className=\"number-setting\" placeholder=\"Hole Multiplier\" type=\"number\" />\r\n                        </div>\r\n                    </div>\r\n                </div>\r\n                <div className=\"algorithm-dropdown dropdown-animate\">\r\n                    <div className=\"pv-menu-bar-button\"\r\n                    onMouseEnter={() => this.setState({algorithmDropdownHidden: false})}\r\n                    onClick={() => this.setState({curAlgorithm: null})}>\r\n                    <span>Algorithm</span></div>\r\n                    <div className=\"pv-menu-dropdown-content alg-drop-content dropdown-animate\"\r\n                    hidden={this.state.algorithmDropdownHidden}>\r\n                        <div className=\"pv-menu-dropdown-content-item\"\r\n                        onClick={() => this.setState({curAlgorithm: pathfindAlgorithms.DIJKSTRA})}\r\n                        >Dijkstra</div>\r\n                        <div className=\"pv-menu-dropdown-content-item\"\r\n                        onClick={() => this.setState({curAlgorithm: pathfindAlgorithms.ASTAR})}\r\n                        >A* (A-Star)</div>\r\n                        <div className=\"pv-menu-dropdown-content-item\"\r\n                        onClick={() => this.setState({curAlgorithm: pathfindAlgorithms.BFS})}\r\n                        >Breadth First Search</div>\r\n                        <div className=\"pv-menu-dropdown-content-item\"\r\n                        onClick={() => this.setState({curAlgorithm: pathfindAlgorithms.DFS})}\r\n                        >Depth First Search</div>\r\n                    </div>\r\n                </div>\r\n                <div className=\"pathfind-dropdown dropdown-animate\">\r\n                    <div className=\"pv-menu-bar-button\" \r\n                    onMouseEnter={() => this.setState({pathfindDropdownHidden: false})}\r\n                    onClick={() => this.props.pathfinder.visualizePathfind(this.state.curAlgorithm, this.state.diagonalNeighbors, this.state.curSpeed)}\r\n                    onMouseUp={() => this.setState({pathfindDropdownHidden: true})}>\r\n                    <span>Pathfind</span></div>\r\n                    <div className=\"pv-menu-dropdown-content pathfind-drop-content dropdown-animate\"\r\n                    hidden={this.state.pathfindDropdownHidden}>\r\n                        <div className=\"pv-menu-dropdown-content-item\"\r\n                        onClick={() => this.changeVisualizeSpeed(\"vslow-bool\", 250)}>\r\n                            <div id=\"vslow-bool\" className=\"bool-setting\" />\r\n                        Very Slow</div>\r\n                        <div className=\"pv-menu-dropdown-content-item\"\r\n                        onClick={() => this.changeVisualizeSpeed(\"slow-bool\", 50)}>\r\n                            <div id=\"slow-bool\" className=\"bool-setting\" />\r\n                        Slow</div>\r\n                        <div className=\"pv-menu-dropdown-content-item\"\r\n                        onClick={() => this.changeVisualizeSpeed(\"fast-bool\", 15)}>\r\n                            <div id=\"fast-bool\" className=\"bool-setting\" />\r\n                        Fast</div>\r\n                        <div className=\"pv-menu-dropdown-content-item\"\r\n                        onClick={() => this.changeVisualizeSpeed(\"vfast-bool\", 5)}>\r\n                            <div id=\"vfast-bool\" className=\"bool-setting\" />\r\n                        Very Fast</div>                    \r\n                        <div className=\"pv-menu-dropdown-content-item\"\r\n                        onClick={() => this.changeVisualizeSpeed(\"instant-bool\", 0)}>\r\n                            <div id=\"instant-bool\" className=\"bool-setting\" />\r\n                        Instant</div>\r\n                    </div>\r\n                </div>\r\n                <div className=\"pv-curalg dropdown-animate\">{this.getCurrentAlgorithmText()}</div>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default PVisualizerSettings;","import React from 'react';\r\n\r\nimport './PathfindMenu.css';\r\n\r\nimport PathfindStats from './PathfindStats';\r\nimport NodeKey from './NodeKey';\r\nimport PVisualizerSettings from './PVisualizerSettings';\r\n\r\n/**\r\n * Represents the menu above the grid of the pathfinding visualizer component.\r\n * \r\n * @author Jake Waclawski\r\n */\r\nclass PathfindMenu extends React.Component {\r\n    constructor (props) {\r\n        super(props);\r\n        this.state = {};\r\n    }\r\n    \r\n    /**\r\n     * Renders the menu component.\r\n     * \r\n     * @returns a <div> element representing the menu\r\n     */\r\n    render () {\r\n        return (\r\n            <div className=\"pathfind-menu\">\r\n                <PVisualizerSettings pathfinder={this.props.pathfinder} />\r\n                <NodeKey pathfinder={this.props.pathfinder} />\r\n                <PathfindStats />\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default PathfindMenu;","import React from 'react';\r\n\r\nimport './PathfindingVisualizer.css';\r\n\r\nimport { getShortestPathNodes, dijkstra, aStar, breadthFirstSearch, depthFirstSearch, pathfindAlgorithms, getShortestPathCost\r\n} from './Algorithms/PathfindAlgorithms';\r\nimport { recursiveDevision, mazeAlgorithms, randomWallMaze, randomWeightMaze, randomWallWeightMaze\r\n} from './Algorithms/MazeAlgorithms';\r\nimport PathfindMenu from './Menu/PathfindMenu';\r\nimport Node from './Grid/Node';\r\n\r\n// Number of rows in the grid\r\nconst ROW_COUNT = 29;\r\n// Number of columns in the grid\r\nconst COL_COUNT = 71;\r\n// Initial cost of weighted nodes\r\nconst INIT_COST = 5;\r\n// Initial coordinates of the start node [row, col]\r\nconst INIT_START = [14, 10];\r\n// Initial coordinates of the target noe [row, col]\r\nconst INIT_TARGET = [14, 60];\r\n// Default speed between visited node animations in miliseconds\r\nconst VISITED_SPEED = 15;\r\n// Speed between shortest path node animations in miliseconds\r\nconst PATH_SPEED = 25;\r\n// Speed between maze wall node animations in miliseconds\r\nconst MAZE_SPEED = 10;\r\n\r\n// Node class types\r\nconst nodeTypes = {\r\n    NODE: 'node',\r\n    NODE_ANIMATED: 'node node-animated',\r\n    WALL: 'node wall',\r\n    WALL_INSTANT: 'node wall-instant',\r\n    WALL_PREVIEW: 'node wall-preview',\r\n    WEIGHT: 'node weight',\r\n    WEIGHT_INSTANT: 'node weight-instant',\r\n    WEIGHT_PREVIEW: 'node weight-preview',\r\n    START: 'node start',\r\n    START_INSTANT: 'node start-instant',\r\n    START_PREVIEW: 'node start-preview',\r\n    TARGET: 'node target',\r\n    TARGET_INSTANT: 'node target-instant',\r\n    TARGET_PREVIEW: 'node target-preview',\r\n    VISITED: 'node visited',\r\n    VISITED_INSTANT: 'node visited-instant',\r\n    VISITED_WEIGHT: 'node visited-weight',\r\n    VISITED_WEIGHT_INSTANT: 'node visited-weight-instant',\r\n    PATH: 'node path',\r\n    PATH_INSTANT: 'node path-instant',\r\n    PATH_WEIGHT: 'node path-weight',\r\n    PATH_WEIGHT_INSTANT: 'node path-weight-instant',\r\n}\r\n\r\n/**\r\n * Represents the pathfinding visualizer component.\r\n * \r\n * @author Jake Waclawski\r\n */\r\nclass PathfindingVisualizer extends React.Component {\r\n    constructor (props) {\r\n        super(props);\r\n        this.state = {\r\n            // Current state of grid nodes\r\n            grid: [],\r\n            // Current cost of weighted nodes\r\n            weightCost: INIT_COST,\r\n            // Is the mouse down?\r\n            mouseIsDown: false,\r\n            // Are we currently allowed to interact with the grid\r\n            interactable: true,\r\n            // Current draw mode (0: none, 1: walls, 2: weights)\r\n            drawMode: 0,\r\n            // Are we erasing or drawing walls (null if neither)?\r\n            drawWall: null,\r\n            // Are we erasing or drawing weights (null if neither)?\r\n            drawWeight: null,\r\n            // Current start node position\r\n            startNode: INIT_START,\r\n            // Current target node position\r\n            targetNode: INIT_TARGET,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the grid with new nodes. Start and target\r\n     * node positions are preserved.\r\n     */\r\n    rebuildGrid () {\r\n        const grid = [];\r\n        for (let r = 0; r < ROW_COUNT; r++) {\r\n            const curRow = [];\r\n            for (let c = 0; c < COL_COUNT; c++) {\r\n                const node = this.createNode(r, c, 1, false);\r\n                curRow.push(node);\r\n            }\r\n            grid.push(curRow);\r\n        }\r\n        this.setState({grid: grid});\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the grid with new nodes. Main node types are\r\n     * preserved (start, target, wall, weight).\r\n     */\r\n    softRebuildGrid () {\r\n        const oldGrid = this.state.grid;\r\n        const grid = [];\r\n        for (let r = 0; r < ROW_COUNT; r++) {\r\n            const curRow = [];\r\n            for (let c = 0; c < COL_COUNT; c++) {\r\n                const node = this.createNode(r, c, oldGrid[r][c].cost, oldGrid[r][c].isWall)\r\n                curRow.push(node);\r\n            }\r\n            grid.push(curRow);\r\n        }\r\n        this.setState({grid: grid});\r\n    }\r\n\r\n    /**\r\n     * Creates a new node with stored properties.\r\n     * \r\n     * @param {int} row row on grid\r\n     * @param {int} col column on grid\r\n     * @param {int} cost weight cost of node\r\n     * @param {boolean} isWall is node a wall\r\n     * \r\n     * @returns the new node object\r\n     */\r\n    createNode (row, col, cost, isWall) {\r\n        let curVisual = nodeTypes.NODE;\r\n        if (cost !== 1) curVisual = nodeTypes.WEIGHT;\r\n        if (isWall) curVisual = nodeTypes.WALL;\r\n\r\n        return {\r\n            curVisual: curVisual,\r\n            row: row,\r\n            col: col,\r\n            cost: cost,\r\n            isStart: row === this.state.startNode[0] && col === this.state.startNode[1],\r\n            isTarget: row === this.state.targetNode[0] && col === this.state.targetNode[1],\r\n            isWall: isWall,\r\n            previousNode: null,\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Updates the state of the grid of nodes. Changes the properties of\r\n     * newly drawn node types according to their current visual state.\r\n     */\r\n    updateGridState () {\r\n        const grid = this.state.grid;\r\n\r\n        for (let r = 0; r < grid.length; r++) {\r\n            for (let c = 0; c < grid[0].length; c++) {\r\n                const node = grid[r][c];\r\n                const type = this.getNodeVisual(node);\r\n\r\n                node.curVisual = nodeTypes.NODE;\r\n                node.isStart = false;\r\n                node.isTarget = false;\r\n                node.isWall = false;\r\n                \r\n                switch (type) {\r\n                    case nodeTypes.START: \r\n                    case nodeTypes.START_INSTANT:\r\n                        node.curVisual = nodeTypes.START_INSTANT;\r\n                        node.cost = 1;\r\n                        node.isStart = true;\r\n                        this.setState({startNode: [node.row, node.col]});\r\n                        break;\r\n                    case nodeTypes.TARGET: \r\n                    case nodeTypes.TARGET_INSTANT:\r\n                        node.curVisual = nodeTypes.TARGET_INSTANT;\r\n                        node.cost = 1;\r\n                        node.isTarget = true;\r\n                        this.setState({targetNode: [node.row, node.col]});\r\n                        break;\r\n                    case nodeTypes.WALL: \r\n                    case nodeTypes.WALL_INSTANT:\r\n                        node.curVisual = nodeTypes.WALL_INSTANT;\r\n                        node.cost = 1;\r\n                        node.isWall = true;\r\n                        break;\r\n                    case nodeTypes.WEIGHT:\r\n                    case nodeTypes.WEIGHT_INSTANT:\r\n                    case nodeTypes.VISITED_WEIGHT:\r\n                    case nodeTypes.VISITED_WEIGHT_INSTANT:\r\n                    case nodeTypes.PATH_WEIGHT:\r\n                    case nodeTypes.PATH_WEIGHT_INSTANT:\r\n                        node.curVisual = nodeTypes.WEIGHT_INSTANT;\r\n                        if (node.cost === 1) node.cost = this.state.weightCost;\r\n                        break;\r\n                    case nodeTypes.VISITED:\r\n                    case nodeTypes.VISITED_INSTANT:\r\n                        node.curVisual = nodeTypes.VISITED_INSTANT;\r\n                        break;\r\n                    case nodeTypes.PATH:\r\n                    case nodeTypes.PATH_INSTANT:\r\n                        node.curVisual = nodeTypes.PATH_INSTANT;\r\n                        break;\r\n                    default:\r\n                        node.cost = 1;\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n\r\n        this.setState({grid: grid});\r\n    }\r\n\r\n    /**\r\n     * Updates the visual state of a given node.\r\n     * \r\n     * @param {Object} node node on grid\r\n     * @param {nodeTypes} type new node type\r\n     */\r\n    updateNodeVisual (node, type) { document.getElementById(`node-${node.row}-${node.col}`).className = type; }\r\n\r\n    /**\r\n     * Gets the current node type.\r\n     * \r\n     * @param {Object} node \r\n     * \r\n     * @returns current node element class name\r\n     */\r\n    getNodeVisual (node) { return document.getElementById(`node-${node.row}-${node.col}`).className; }\r\n\r\n    /**\r\n     * Sets new start node position. Updates state, we are no\r\n     * longer placing the start node.\r\n     * \r\n     * @param {Object} node node on grid\r\n     */\r\n    drawStartNode (node) { \r\n        const curStart = this.state.grid[this.state.startNode[0]][this.state.startNode[1]];\r\n\r\n        if (node.isStart || node.isTarget) return;\r\n\r\n        this.updateNodeVisual(curStart, nodeTypes.NODE_ANIMATED);\r\n        this.updateNodeVisual(node, nodeTypes.START);\r\n    }\r\n\r\n    /**\r\n     * Sets new target node position. Updates state, we are no\r\n     * longer placing the target node.\r\n     * \r\n     * @param {Object} node node on grid\r\n     */\r\n    drawTargetNode (node) { \r\n        const curTarget = this.state.grid[this.state.targetNode[0]][this.state.targetNode[1]];\r\n\r\n        if (node.isStart || node.isTarget) return;\r\n\r\n        this.updateNodeVisual(curTarget, nodeTypes.NODE_ANIMATED);\r\n        this.updateNodeVisual(node, nodeTypes.TARGET);\r\n    }\r\n\r\n    /**\r\n     * Updates the visual wall state of a given node. \r\n     * \r\n     * @param {Object} node node on grid\r\n     * @param {boolean} isWall are we drawing (true) or erasing (false)\r\n     */\r\n    drawWallNode (node, isWall) {\r\n        if (node.isStart || node.isTarget) return;\r\n\r\n        if (!isWall) {\r\n            if (this.getNodeVisual(node) === nodeTypes.NODE) return; \r\n            this.updateNodeVisual(node, nodeTypes.NODE_ANIMATED)\r\n        } else if (this.getNodeVisual(node) !== nodeTypes.WALL_INSTANT) {\r\n            this.updateNodeVisual(node, nodeTypes.WALL);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Updates the visual weight state of a given node.\r\n     * \r\n     * @param {Object} node node on grid\r\n     * @param {boolean} isWeight are we drawing (true) or erasing (false)\r\n     */\r\n    drawWeightNode (node, isWeight) {\r\n        if (node.isWall || node.isStart || node.isTarget) return;\r\n\r\n        if (!isWeight) {\r\n            if (this.getNodeVisual(node) === nodeTypes.NODE) return; \r\n            this.updateNodeVisual(node, nodeTypes.NODE_ANIMATED);\r\n        } else if (this.getNodeVisual(node) !== nodeTypes.WEIGHT_INSTANT) {\r\n            this.updateNodeVisual(node, nodeTypes.WEIGHT);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Updates the visual visited state of a given node.\r\n     * \r\n     * @param {Object} node node on grid\r\n     * @param {boolean} isInstant true if drawing instantly\r\n     */\r\n    drawVisitedNode (node, isInstant) {\r\n        if (node.isWall || node.isStart || node.isTarget) return;\r\n\r\n        const isWeight = node.cost !== 1;\r\n\r\n        if (isInstant) {\r\n            if (isWeight) this.updateNodeVisual(node, nodeTypes.VISITED_WEIGHT_INSTANT);\r\n            else this.updateNodeVisual(node, nodeTypes.VISITED_INSTANT);\r\n        } else {\r\n            if (isWeight) this.updateNodeVisual(node, nodeTypes.VISITED_WEIGHT);\r\n            else this.updateNodeVisual(node, nodeTypes.VISITED);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Updates the visual path state of a given node.\r\n     * \r\n     * @param {Object} node node on grid\r\n     * @param {boolean} isInstant true if drawing instantly\r\n     */\r\n    drawPathNode (node, isInstant) {\r\n        if (node.isWall || node.isStart || node.isTarget) return;\r\n\r\n        const isWeight = node.cost !== 1;\r\n\r\n        if (isInstant) {\r\n            if (isWeight) this.updateNodeVisual(node, nodeTypes.PATH_WEIGHT_INSTANT);\r\n            else this.updateNodeVisual(node, nodeTypes.PATH_INSTANT);\r\n        } else {\r\n            if (isWeight) this.updateNodeVisual(node, nodeTypes.PATH_WEIGHT);\r\n            else this.updateNodeVisual(node, nodeTypes.PATH);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clears the entire grid.\r\n     */\r\n    clearGrid () {\r\n        this.clearWeights();\r\n        this.clearWalls();\r\n        this.clearPaths();\r\n    }\r\n\r\n    /**\r\n     * Clears the grid of all wall nodes.\r\n     */\r\n    clearWalls () { \r\n        if (!this.state.interactable) return;\r\n\r\n        const grid = this.state.grid;\r\n        for (const row of grid) {\r\n            for (const node of row) {\r\n                if (node.isWall) {\r\n                    this.updateNodeVisual(node, nodeTypes.NODE);\r\n                    node.isWall = false;\r\n                }\r\n            }\r\n        }\r\n        this.setState({grid: grid});\r\n        this.updateGridState();\r\n    }\r\n\r\n    /**\r\n     * Clears the grid of all weighted nodes and resets their\r\n     * costs to 1.\r\n     */\r\n    clearWeights () {\r\n        if (!this.state.interactable) return;\r\n\r\n        const grid = this.state.grid;\r\n        for (const row of grid) {\r\n            for (const node of row) {\r\n                if (node.cost !== 1) {\r\n                    this.updateNodeVisual(node, nodeTypes.NODE);\r\n                    node.cost = 1;\r\n                }\r\n            }\r\n        }\r\n        this.setState({grid: grid});\r\n        this.updateGridState();\r\n    }\r\n\r\n    /**\r\n     * Clears the visual grid of all path and visited type nodes.\r\n     * Updates the class name of each appropriate node object.\r\n     */\r\n    clearPaths () {\r\n        if (!this.state.interactable) return;\r\n\r\n        for (let r = 0; r < ROW_COUNT; r++) {\r\n            for (let c = 0; c < COL_COUNT; c++) {\r\n                const node = this.state.grid[r][c];\r\n                const type = this.getNodeVisual(node);\r\n\r\n                if (type === nodeTypes.VISITED || \r\n                    type === nodeTypes.VISITED_INSTANT ||\r\n                    type === nodeTypes.PATH || \r\n                    type === nodeTypes.PATH_INSTANT) {\r\n\r\n                    this.updateNodeVisual(node, nodeTypes.NODE);\r\n                }\r\n                else if (type === nodeTypes.VISITED_WEIGHT || \r\n                    type === nodeTypes.VISITED_WEIGHT_INSTANT || \r\n                    type === nodeTypes.PATH_WEIGHT ||\r\n                    type === nodeTypes.PATH_WEIGHT_INSTANT) {\r\n                \r\n                    this.updateNodeVisual(node, nodeTypes.WEIGHT_INSTANT);\r\n                }\r\n            }\r\n        }\r\n        this.updateAlgorithmInfo(0, 0, 0);\r\n        this.updateGridState();\r\n    }\r\n\r\n    /**\r\n     * Resets the start and target nodes to their initial locations.\r\n     */\r\n    resetStartTarget () {\r\n        if (!this.state.interactable) return;\r\n\r\n        this.clearPaths();\r\n\r\n        const initStart = this.state.grid[INIT_START[0]][INIT_START[1]];\r\n        const initTarget = this.state.grid[INIT_TARGET[0]][INIT_TARGET[1]];\r\n\r\n        this.drawStartNode(initStart);\r\n        this.drawTargetNode(initTarget);\r\n        this.updateGridState();\r\n    }\r\n\r\n    /**\r\n     * Sets new cost of weighted nodes.\r\n     * \r\n     * @param {int} weight new cost\r\n     */\r\n    setNewWeight (weight) { this.setState({weightCost: weight}); }\r\n\r\n    /**\r\n     * Sets the current draw mode.\r\n     * \r\n     * 0: none\r\n     * 1: walls\r\n     * 2: weights\r\n     * 3: start\r\n     * 4: target\r\n     * \r\n     * @param {int} mode new draw mode\r\n     */\r\n    setDrawMode (mode) { \r\n        if (this.state.drawMode === mode) mode = 0;\r\n        this.setState({drawMode: mode}); \r\n    }\r\n\r\n    /**\r\n     * Visualizes a given pathfinding algorithm. Uses the current state of\r\n     * the grid of nodes.\r\n     * \r\n     * @param {pathfindAlgorithms} algorithm pathfinding algorithm\r\n     * @param {boolean} diagonalNeighbors\r\n     * @param {int} speed time in miliseconds between visit animations\r\n     */\r\n    visualizePathfind (algorithm, diagonalNeighbors, speed) {\r\n        if (!this.state.interactable) return;\r\n\r\n        this.setState({drawMode: 0});\r\n        this.clearPaths();\r\n        this.softRebuildGrid();\r\n\r\n        const grid = this.state.grid;\r\n        const start = grid[this.state.startNode[0]][this.state.startNode[1]];\r\n        const target = grid[this.state.targetNode[0]][this.state.targetNode[1]];\r\n\r\n        var visitedNodes = [];\r\n        switch (algorithm) {\r\n            case pathfindAlgorithms.DIJKSTRA:\r\n                visitedNodes = dijkstra(grid, start, target, diagonalNeighbors);\r\n                break;\r\n            case pathfindAlgorithms.ASTAR:\r\n                visitedNodes = aStar(grid, start, target, diagonalNeighbors);\r\n                break;\r\n            case pathfindAlgorithms.BFS:\r\n                visitedNodes = breadthFirstSearch(grid, start, target, diagonalNeighbors);\r\n                break;\r\n            case pathfindAlgorithms.DFS:\r\n                visitedNodes = depthFirstSearch(grid, start, target, diagonalNeighbors);\r\n                break;\r\n            default:\r\n                return;\r\n        }\r\n\r\n        const shortestPath = getShortestPathNodes(target);\r\n        const totalCost = getShortestPathCost(target);\r\n\r\n        this.updateAlgorithmInfo(visitedNodes.length, shortestPath.length, totalCost);\r\n\r\n        this.animateSearch(visitedNodes, shortestPath, speed);\r\n    }\r\n\r\n    /**\r\n     * Animates the process of the pathfinding algorithm. Updates the class\r\n     * names of the nodes to change their appearance.\r\n     * \r\n     * @param {Array} visitedNodes array of visited nodes in order\r\n     * @param {Array} shortestPath array of shortest path nodes in order\r\n     * @param {int} speed time in miliseconds between visit animations\r\n     */\r\n    animateSearch (visitedNodes, shortestPath, speed) {\r\n        const isInstant = speed === 0;\r\n        if (!speed) speed = VISITED_SPEED;\r\n\r\n        if (isInstant) {\r\n            for (let i = 0; i < visitedNodes.length; i++) {\r\n                const node = visitedNodes[i];\r\n                this.drawVisitedNode(node, isInstant);\r\n            }\r\n            this.animatePath(shortestPath, isInstant);\r\n        } else {\r\n            this.setState({interactable: false});\r\n\r\n            for (let i = 0; i < visitedNodes.length; i++) {\r\n                setTimeout(() => {\r\n                    const node = visitedNodes[i];\r\n                    this.drawVisitedNode(node, isInstant);\r\n                }, speed * i);\r\n            }\r\n            setTimeout(() => { this.animatePath(shortestPath, isInstant); }, speed * visitedNodes.length);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Animates the shortest path from the start node to the target node.\r\n     * Updates the class names of the nodes to change their appearance.\r\n     * \r\n     * @param {Array} shortestPath array of shortest path nodes in order \r\n     * @param {boolean} isInstant true if drawing instantly\r\n     */\r\n    animatePath (shortestPath, isInstant) {\r\n        if (isInstant) {\r\n            for (let i = 1; i < shortestPath.length; i++) {\r\n                const node = shortestPath[i];\r\n                this.drawPathNode(node, isInstant);\r\n            }\r\n            setTimeout(() => { this.updateGridState() }, 0);\r\n        } else {\r\n            for (let i = 0; i < shortestPath.length; i++) {\r\n                setTimeout(() => {\r\n                    const node = shortestPath[i];\r\n                    this.drawPathNode(node, isInstant)\r\n                }, PATH_SPEED * i);\r\n            }\r\n            setTimeout(() => { \r\n                this.updateGridState();\r\n                this.setState({interactable: true});\r\n            }, (PATH_SPEED * shortestPath.length) + 1000);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Updates the visual algorithm pathfind information.\r\n     * \r\n     * @param {int} visitedNodes amount of nodes visited\r\n     * @param {int} pathNodes amount of nodes in path\r\n     * @param {int} totalCost total cost of shortest path\r\n     */\r\n    updateAlgorithmInfo (visitedNodes, pathNodes, totalCost) {\r\n        if (pathNodes <= 1) pathNodes = 0;\r\n        if (totalCost <= 1) totalCost = 0;\r\n\r\n        document.getElementById(\"pv-stats-visited\").innerHTML = `${visitedNodes}`;\r\n        document.getElementById(\"pv-stats-path\").innerHTML = `${pathNodes}`;\r\n        document.getElementById(\"pv-stats-weighted\").innerHTML = `${totalCost}`;\r\n    }\r\n\r\n    /**\r\n     * Animates a generated maze.\r\n     * \r\n     * @param {mazeAlgorithms} algorithm maze algorithm to use\r\n     */\r\n    animateMaze (algorithm) {\r\n        var maze = [];\r\n\r\n        switch (algorithm) {\r\n            case mazeAlgorithms.RECURSIVE_DEVISION:\r\n                maze = recursiveDevision(ROW_COUNT, COL_COUNT);\r\n                break;\r\n            case mazeAlgorithms.RANDOM_WALL:\r\n                maze = randomWallMaze(ROW_COUNT, COL_COUNT);\r\n                break;\r\n            case mazeAlgorithms.RANDOM_WEIGHT:\r\n                maze = randomWeightMaze(ROW_COUNT, COL_COUNT);\r\n                break;\r\n            case mazeAlgorithms.RANDOM_WALL_WEIGHT:\r\n                maze = randomWallWeightMaze(ROW_COUNT, COL_COUNT);\r\n                break;\r\n            default:\r\n                return;\r\n        }\r\n\r\n        if (!this.state.interactable) return;\r\n        this.setState({interactable: false});\r\n        this.clearGrid();\r\n\r\n        for (let i = 0; i < maze.length; i++) {\r\n            setTimeout(() => {\r\n                const node = this.state.grid[maze[i][0]][maze[i][1]];\r\n                if (maze[i][2]) this.drawWeightNode(node, true);\r\n                else this.drawWallNode(node, true);\r\n            }, MAZE_SPEED * i);\r\n        }\r\n        setTimeout(() => {\r\n            this.updateGridState();\r\n            this.setState({interactable: true});\r\n        }, MAZE_SPEED * maze.length);\r\n    }\r\n\r\n    /**\r\n     * Runs on page load. Rebuilds the grid.\r\n     */\r\n    componentDidMount () { this.rebuildGrid(); }\r\n\r\n    /**\r\n     * Handles a mouse down event on a node. If we are placing the start or\r\n     * target node, update the node location and return. Otherwise, updates\r\n     * the node based on the current draw mode.\r\n     * \r\n     * @param {int} row row of node on grid\r\n     * @param {int} col column of node on grid\r\n     */\r\n    handleMouseDown (row, col) {\r\n        if (!this.state.interactable) return;\r\n        this.setState({mouseIsDown: true});\r\n\r\n        const grid = this.state.grid;\r\n        const node = grid[row][col];\r\n        if (node.isStart || node.isTarget) return;\r\n\r\n        switch (this.state.drawMode) {\r\n            case 1: // Wall\r\n                const isWall = node.isWall;\r\n                this.drawWallNode(node, !isWall);\r\n                this.setState({drawWall: !isWall});\r\n                break;\r\n            case 2: // Weight\r\n                const isWeight = node.cost !== 1;\r\n                this.drawWeightNode(node, !isWeight);\r\n                this.setState({drawWeight: !isWeight});\r\n                break;\r\n            case 3: // Start\r\n                this.clearPaths();\r\n                this.drawStartNode(node);\r\n                this.setState({drawMode: 0});\r\n                break;\r\n            case 4: // Target\r\n                this.clearPaths();\r\n                this.drawTargetNode(node);\r\n                this.setState({drawMode: 0});\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handles a mouse up event. Sets the state so that nothing\r\n     * can be drawn.\r\n     */\r\n    handleMouseUp () {\r\n        if (!this.state.mouseIsDown) return;\r\n\r\n        this.updateGridState();\r\n\r\n        this.setState({\r\n            mouseIsDown: false,\r\n            drawWall: null,\r\n            drawWeight: null,\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Handles a mouse enter event into a node. If the mouse is not down,\r\n     * return. Otherwise, updates the node based on the current draw mode.\r\n     * \r\n     * @param {int} row row of node on grid\r\n     * @param {int} col column of node on grid\r\n     */\r\n    handleMouseEnter (row, col) {\r\n        if (!this.state.interactable) return;\r\n\r\n        const grid = this.state.grid;\r\n        const node = grid[row][col];\r\n\r\n        const isWall = node.isWall;\r\n        const isWeight = node.cost !== 1;\r\n\r\n        const isPreview = !isWall && !isWeight && !node.isStart && !node.isTarget;\r\n\r\n        switch (this.state.drawMode) {\r\n            case 1:\r\n                if (this.state.mouseIsDown && isWall !== this.state.drawWall) {\r\n                    this.drawWallNode(node, !isWall);\r\n                } else if (!this.state.mouseIsDown && isPreview) this.updateNodeVisual(node, nodeTypes.WALL_PREVIEW);\r\n                break;\r\n            case 2:\r\n                if (this.state.mouseIsDown && isWeight !== this.state.drawWeight) {\r\n                    this.drawWeightNode(node, !isWeight);\r\n                } else if (!this.state.mouseIsDown && isPreview) this.updateNodeVisual(node, nodeTypes.WEIGHT_PREVIEW);\r\n                break; \r\n            case 3:\r\n                if (isPreview) this.updateNodeVisual(node, nodeTypes.START_PREVIEW);\r\n                break;\r\n            case 4:\r\n                if (isPreview) this.updateNodeVisual(node, nodeTypes.TARGET_PREVIEW);\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handles a mouse leave event from a node.\r\n     * \r\n     * @param {int} row row of node on grid\r\n     * @param {int} col column of node on grid\r\n     */\r\n    handleMouseLeft (row, col) {\r\n        if (this.state.mouseIsDown || this.state.drawMode === 0 || !this.state.interactable) return;\r\n        \r\n        const node = this.state.grid[row][col];\r\n\r\n        if (node.isWall || node.cost !== 1 || node.isStart || node.isTarget) return;\r\n\r\n        this.updateNodeVisual(node, node.curVisual);\r\n    }\r\n\r\n    /**\r\n     * Handles an animation end event of a node. Updates the class name of the\r\n     * node to the instant class version.\r\n     * \r\n     * @param {Object} node node on grid\r\n     */\r\n    handleAnimationEnd (node) {\r\n        const type = this.getNodeVisual(node);\r\n        switch (type) {\r\n            case nodeTypes.START:\r\n                this.updateNodeVisual(node, nodeTypes.START_INSTANT);\r\n                break;\r\n            case nodeTypes.TARGET:\r\n                this.updateNodeVisual(node, nodeTypes.TARGET_INSTANT);\r\n                break;\r\n            case nodeTypes.WALL:\r\n                this.updateNodeVisual(node, nodeTypes.WALL_INSTANT);\r\n                break;\r\n            case nodeTypes.WEIGHT:\r\n                this.updateNodeVisual(node, nodeTypes.WEIGHT_INSTANT);\r\n                break;\r\n            case nodeTypes.VISITED:\r\n                this.updateNodeVisual(node, nodeTypes.VISITED_INSTANT);\r\n                break;\r\n            case nodeTypes.VISITED_WEIGHT:\r\n                this.updateNodeVisual(node, nodeTypes.VISITED_WEIGHT_INSTANT);\r\n                break;\r\n            case nodeTypes.PATH:\r\n                this.updateNodeVisual(node, nodeTypes.PATH_INSTANT);\r\n                break;\r\n            case nodeTypes.PATH_WEIGHT:\r\n                this.updateNodeVisual(node, nodeTypes.PATH_WEIGHT_INSTANT);\r\n                break;\r\n            default:\r\n                this.updateNodeVisual(node, nodeTypes.NODE);\r\n                break;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Renders the pathfinding visualizer component.\r\n     * \r\n     * @returns a <div> element representing the component\r\n     */\r\n    render () {\r\n        //console.log(this.state.grid);\r\n\r\n        return (\r\n            <div className=\"pathfind-vis\">\r\n                <div className=\"pathfind-menu\">\r\n                    <PathfindMenu pathfinder={this} />\r\n                </div>\r\n                <div \r\n                className=\"grid\" \r\n                onMouseUp={() => this.handleMouseUp()}\r\n                onMouseLeave={() => this.handleMouseUp()}\r\n                onContextMenu={(e) => e.preventDefault()}\r\n                onDragStart={(e) => e.preventDefault()}\r\n                >\r\n                    {Array.from(this.state.grid).map((row, rowIdx) => {\r\n                        return (\r\n                            <div key={rowIdx} className=\"grid-row\">\r\n                                {Array.from(row).map((node, nodeIdx) => {\r\n                                    const {row, col, cost, isStart, isTarget} = node;\r\n                                    return (\r\n                                        <Node key={nodeIdx}\r\n                                        row={row}\r\n                                        col={col}\r\n                                        cost={cost}\r\n                                        isStart={isStart}\r\n                                        isTarget={isTarget}\r\n                                        mousePressed={(row, col) => this.handleMouseDown(row, col)}\r\n                                        mouseEntered={(row, col) => this.handleMouseEnter(row, col)}\r\n                                        mouseLeft={(row, col) => this.handleMouseLeft(row, col)}\r\n                                        animationEnded={() => this.handleAnimationEnd(node)}\r\n                                        />\r\n                                    );\r\n                                })}\r\n                            </div>\r\n                        );\r\n                    })}\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default PathfindingVisualizer;","// Unsorted bar color\r\nconst UNSORTED = \"pink\";\r\n// Comparing bar color\r\nconst COMPARE = \"red\";\r\n// Sorted bar color\r\nconst SORTED = \"green\";\r\n// Swapping bar color\r\nconst SWAP = \"orange\";\r\n// Minimum bar color\r\nconst MIN = \"purple\";\r\n\r\n// Sorting algorithms\r\nexport const sortAlgorithms = {\r\n    SELECTION: \"Selection Sort\",\r\n    INSERTION: \"Insertion Sort\",\r\n    MERGE: \"Merge Sort\",\r\n}\r\n\r\n/**\r\n * Executes a Selection Sort on an array.\r\n * \r\n * @param {Array} array array of values\r\n * \r\n * @returns an array of animations\r\n */\r\nexport function selectionSort(array) {\r\n    const animations = [];\r\n\r\n    for (let i = 0; i < array.length; i++) {\r\n        var min = i;\r\n        animations.push([[MIN, min]]);\r\n        var newMin = true;\r\n        for (let k = i + 1; k < array.length; k++) {\r\n            if (newMin) {\r\n                animations.push([[COMPARE, k]]);\r\n                newMin = false;\r\n            } else animations.push([[UNSORTED, k-1], [COMPARE, k]]);\r\n            \r\n            if (array[min] > array[k]) {\r\n                animations.push([[UNSORTED, min], [MIN, k]]);\r\n                min = k;\r\n                newMin = true;\r\n            }\r\n        }\r\n        if (min !== i) {\r\n            animations.push([[UNSORTED, array.length-1], [SWAP, min, i], [null, min, array[i]], [null, i, array[min]]]);\r\n            animations.push([[UNSORTED, min], [SORTED, i]]);\r\n            var temp = array[i];\r\n            array[i] = array[min];\r\n            array[min] = temp;\r\n        } else animations.push([[UNSORTED, array.length-1], [SORTED, i]]);\r\n    }\r\n\r\n    return animations;\r\n}\r\n\r\n/**\r\n * Executes a Insertion Sort on an array.\r\n * \r\n * @param {Array} array array of values\r\n * \r\n * @returns an array of animations\r\n */\r\nexport function insertionSort(array) {\r\n    const animations = [];\r\n\r\n    for (let i = 1; i < array.length; i++) {\r\n        var cur = array[i];\r\n        var j = i - 1;\r\n        \r\n        animations.push([[COMPARE, j, i]]);\r\n        while (j >= 0) {\r\n            if (j + 2 >= array.length) animations.push([[COMPARE, j, j + 1]]);\r\n            else animations.push([[UNSORTED, j + 2], [COMPARE, j, j + 1]]);\r\n            if (array[j] <= cur) {\r\n                animations.push([[UNSORTED, j, j + 1]]);\r\n                break;\r\n            }\r\n            animations.push([[SWAP, j, j + 1], [null, j + 1, array[j]], [null, j, cur]]);\r\n            array[j + 1] = array[j];\r\n            j--;\r\n        }\r\n        if (j + 2 >= array.length) animations.push([[UNSORTED, j + 1]]);\r\n        else animations.push([[UNSORTED, j + 1, j + 2]]);\r\n        animations.push([[null, j + 1, cur]]);\r\n        array[j+1] = cur;\r\n    }\r\n    for (let i = array.length - 1; i >= 0; i--) animations.push([[SORTED, i]]);\r\n\r\n    return animations;\r\n}\r\n\r\n/**\r\n * Executes a Merge Sort on an array.\r\n * \r\n * @param {Array} array array of values\r\n * \r\n * @returns an array of animations\r\n */\r\nexport function mergeSort(array) {\r\n    const animations = [];\r\n    array = doMergeSort(animations, array);\r\n    return animations;\r\n}\r\n\r\n/**\r\n * Actual recursive Merge Sort function.\r\n * \r\n * @param {Array} animations array of animations\r\n * @param {Array} array array of values \r\n * \r\n * @returns sorted array\r\n */\r\nfunction doMergeSort(animations, array) {\r\n    const middle = array.length / 2;\r\n    if (array.length < 2) return array;\r\n    const left = array.splice(0, middle);\r\n    return merge(animations, doMergeSort(animations, left), doMergeSort(animations, array));\r\n}\r\n\r\n/**\r\n * Merge Sort helper function.\r\n * \r\n * @param {Array} animations array of animations\r\n * @param {Array} left left array\r\n * @param {Array} right right array\r\n * \r\n * @returns merged array\r\n */\r\nfunction merge (animations, left, right) {\r\n    var array = [];\r\n\r\n    while (left.length && right.length) {\r\n        if (left[0] < right[0]) array.push(left.shift());\r\n        else array.push(right.shift());\r\n    }\r\n    return [...array, ...left, ...right];\r\n}","import React from 'react';\r\n\r\nimport { sortAlgorithms } from '../Algorithms/SortAlgorithms';\r\n\r\n/**\r\n * Represents the settings bar in the menu of the sorting visualizer\r\n * component.\r\n * \r\n * @author Jake Waclawski\r\n */\r\nclass SVisualizerSettings extends React.Component {\r\n    constructor (props) {\r\n        super(props);\r\n        this.state = {\r\n            // Currently selected sorting algorithm\r\n            curAlgorithm: null,\r\n            // Is the randomize button dropdown open?\r\n            randomizeDropdownHidden: true,\r\n            // Is the algorithm button dropdown open?\r\n            algorithmDropdownHidden: true,\r\n            // Is the visualize button dropdown open?\r\n            visualizeDropdownHidden: true,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets the current algorithm for the information text as a string.\r\n     * \r\n     * @returns the string\r\n     */\r\n    getCurrentAlgorithmText() {\r\n        if (!this.state.curAlgorithm) return \"Select an Algorithm\";\r\n        return this.state.curAlgorithm;\r\n    }\r\n\r\n    /**\r\n     * Renders the settings bar component.\r\n     * \r\n     * @returns a <div> element representing the settings bar\r\n     */\r\n    render () {\r\n\r\n        return (\r\n            <div className=\"sv-menu-bar\">\r\n                <div className=\"randomize-dropdown dropdown-animate\">\r\n                    <div className=\"sv-menu-bar-button\" \r\n                    onClick={() => this.props.sorter.reGenerateArray()}\r\n                    onMouseEnter={() => this.setState({randomizeDropdownHidden: false})}>\r\n                    <span>Randomize</span></div>\r\n                    <div className=\"sv-menu-dropdown-content randomize-drop-content dropdown-animate\"\r\n                    hidden={this.state.randomizeDropdownHidden}\r\n                    onClick={() => this.setState({randomizeDropdownHidden: true})}>\r\n                        <div className=\"sv-menu-dropdown-content-item\"\r\n                        onClick={() => this.props.sorter.reGenerateArray(10)}\r\n                        >Small Array</div>\r\n                        <div className=\"sv-menu-dropdown-content-item\"\r\n                        onClick={() => this.props.sorter.reGenerateArray(50)}\r\n                        >Medium Array</div>\r\n                        <div className=\"sv-menu-dropdown-content-item\"\r\n                        onClick={() => this.props.sorter.reGenerateArray(100)}\r\n                        >Large Array</div>\r\n                    </div>\r\n                </div>\r\n                <div className=\"algorithm-dropdown dropdown-animate\">\r\n                    <div className=\"sv-menu-bar-button\" \r\n                    onMouseEnter={() => this.setState({algorithmDropdownHidden: false})}>\r\n                    <span>Algorithm</span></div>\r\n                    <div className=\"sv-menu-dropdown-content algorithm-drop-content dropdown-animate\"\r\n                    hidden={this.state.algorithmDropdownHidden}\r\n                    onClick={() => this.setState({algorithmDropdownHidden: true})}>\r\n                        <div className=\"sv-menu-dropdown-content-item\"\r\n                        onClick={() => this.setState({curAlgorithm: sortAlgorithms.SELECTION})}\r\n                        >Selection Sort</div>\r\n                        <div className=\"sv-menu-dropdown-content-item\"\r\n                        onClick={() => this.setState({curAlgorithm: sortAlgorithms.INSERTION})}\r\n                        >Insertion Sort</div>\r\n                        <div className=\"sv-menu-dropdown-content-item\"\r\n                        onClick={() => this.setState({curAlgorithm: sortAlgorithms.MERGE})}\r\n                        >Merge Sort</div>\r\n                    </div>\r\n                </div>\r\n                <div className=\"visualize-dropdown dropdown-animate\">\r\n                    <div className=\"sv-menu-bar-button\" \r\n                    onClick={() => this.props.sorter.visualizeSort(this.state.curAlgorithm)}\r\n                    onMouseEnter={() => this.setState({visualizeDropdownHidden: false})}>\r\n                    <span>Sort</span></div>\r\n                    <div className=\"sv-menu-dropdown-content visualize-drop-content dropdown-animate\"\r\n                    hidden={this.state.visualizeDropdownHidden}\r\n                    onClick={() => this.setState({visualizeDropdownHidden: true})}>\r\n                        <div className=\"sv-menu-dropdown-content-item\"\r\n                        onClick={() => this.props.sorter.visualizeSort(this.state.curAlgorithm, 500)}\r\n                        >Very Slow</div>\r\n                        <div className=\"sv-menu-dropdown-content-item\"\r\n                        onClick={() => this.props.sorter.visualizeSort(this.state.curAlgorithm, 100)}\r\n                        >Slow</div>\r\n                        <div className=\"sv-menu-dropdown-content-item\"\r\n                        onClick={() => this.props.sorter.visualizeSort(this.state.curAlgorithm, 50)}\r\n                        >Fast</div>\r\n                        <div className=\"sv-menu-dropdown-content-item\"\r\n                        onClick={() => this.props.sorter.visualizeSort(this.state.curAlgorithm, 10)}\r\n                        >Very Fast</div>\r\n                    </div>\r\n                </div>\r\n                <div className=\"sv-curalg dropdown-animate\">{this.getCurrentAlgorithmText()}</div>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default SVisualizerSettings;","import React from 'react';\r\n\r\nimport './SortMenu.css';\r\n\r\nimport SVisualizerSettings from './SVisualizerSettings';\r\n\r\n/**\r\n * Represents the top menu of the sorting visualizer component.\r\n * \r\n * @author Jake Waclawski\r\n */\r\nclass SortMenu extends React.Component {\r\n    constructor (props) {\r\n        super(props);\r\n        this.state = {};\r\n    }\r\n \r\n    /**\r\n     * Renders the menu component.\r\n     * \r\n     * @returns a <div> element representing the menu\r\n     */\r\n    render () {\r\n        return (\r\n            <div className=\"sort-menu\">\r\n                <SVisualizerSettings sorter={this.props.sorter} />\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default SortMenu;","import React from 'react';\r\n\r\nimport './SortingVisualizer.css';\r\n\r\nimport SortMenu from './Menu/SortMenu';\r\nimport { selectionSort, insertionSort, mergeSort, sortAlgorithms } from './Algorithms/SortAlgorithms';\r\n\r\n// Size of array\r\nconst ARRAY_SIZE = 100;\r\n// Minimum value in array\r\nconst MIN_VALUE = 5;\r\n// Maximum value in array\r\nconst MAX_VALUE = 500;\r\n// Default speed between animations in miliseconds\r\nconst DEFAULT_SPEED = 10;\r\n\r\n// Unsorted bar color\r\nconst UNSORTED = \"pink\";\r\n\r\n/**\r\n * Represents the sorting visualizer component.\r\n * \r\n * @author Jake Waclawski\r\n */\r\nclass SortingVisualizer extends React.Component {\r\n    constructor (props) {\r\n        super(props);\r\n        // Array of bar values\r\n        this.state = { array: [] };\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the array with new random values.\r\n     * \r\n     * @param {int} size size of array\r\n     * @param {int} min minimum value\r\n     * @param {int} max maximum value\r\n     */\r\n    rebuildArray (size, min, max) {\r\n        const array = [];\r\n        for (let i = 0; i < size; i++) { array.push(this.createBar(min, max)); }\r\n        return array;\r\n    }\r\n\r\n    /**\r\n     * Creates a new bar with a random value.\r\n     * \r\n     * @param {int} min lower bound of value\r\n     * @param {int} max upper bound of value\r\n     * \r\n     * @returns the created bar\r\n     */\r\n    createBar (min, max) { return Math.floor(Math.random() * (max - min + 1) + min); }\r\n\r\n    /**\r\n     * Rebuilds the array and regenerates the visual array bars.\r\n     * \r\n     * @param {int} size size of new array\r\n     */\r\n    reGenerateArray (size) { \r\n        if (!size) size = ARRAY_SIZE;\r\n\r\n        const bars = document.getElementsByClassName(\"bar\");\r\n        for (let i = 0; i < this.state.array.length; i++) { bars[i].style.backgroundColor = UNSORTED; }\r\n\r\n        const array = this.rebuildArray(size, MIN_VALUE, MAX_VALUE);\r\n        this.setState({array: array}); \r\n    }\r\n\r\n    /**\r\n     * Visualizes a given sorting algorithm.\r\n     * \r\n     * @param {sortAlgorithms} algorithm sorting algorithm\r\n     * @param {int} speed time between animations in miliseconds\r\n     */\r\n    visualizeSort (algorithm, speed) {\r\n        const array = this.state.array;\r\n        var animations = [];\r\n\r\n        switch (algorithm) {\r\n            case sortAlgorithms.SELECTION:\r\n                animations = selectionSort(array);\r\n                break;\r\n            case sortAlgorithms.INSERTION:\r\n                animations = insertionSort(array);\r\n                break;\r\n            case sortAlgorithms.MERGE:\r\n                animations = mergeSort(array);\r\n                break;\r\n            default:\r\n                return;\r\n        }\r\n\r\n        this.animateSort(animations, speed);\r\n    }\r\n\r\n    /**\r\n     * Animates the process of the sorting algorithm. Iterates through an\r\n     * array of animation steps generated by the algorithm.\r\n     * \r\n     * @param {Array} animations array of animations\r\n     * @param {int} speed time between animations in miliseconds\r\n     */\r\n    animateSort (animations, speed) {\r\n        if (!speed) speed = DEFAULT_SPEED;\r\n\r\n        const bars = document.getElementsByClassName(\"bar\");\r\n\r\n        var i = 0\r\n        for (const step of animations) {\r\n            setTimeout(() => {\r\n                for (const action of step) { \r\n                    if (action[0] === null) {\r\n                        bars[action[1]].style.height = `${action[2]}px`;\r\n                    } else {\r\n                        for (let k = 1; k < action.length; k++) {\r\n                            bars[action[k]].style.backgroundColor = action[0]; \r\n                        }\r\n                    }\r\n                }\r\n            }, speed * i++);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Runs on page load. Rebuilds the array.\r\n     */\r\n    componentDidMount () {\r\n        const array = this.rebuildArray(ARRAY_SIZE, MIN_VALUE, MAX_VALUE);\r\n        this.setState({array: array});\r\n    }\r\n\r\n    /**\r\n     * Renders the sorting visualizer component.\r\n     * \r\n     * @returns a <div> element representing the component\r\n     */\r\n    render () {\r\n        //console.log(this.state.array);\r\n\r\n        return (\r\n            <div className=\"sort-vis\">\r\n                <div className=\"sort-menu\">\r\n                    <SortMenu sorter={this}/>\r\n                </div>\r\n                <div className=\"array\">\r\n                    {Array.from(this.state.array).map((bar, barIdx) => {\r\n                        return (\r\n                            <div className=\"bar\"\r\n                            key={barIdx}\r\n                            style={{\r\n                                backgroundColor: UNSORTED,\r\n                                height: `${bar}px`,\r\n                            }}/>\r\n                        );\r\n                    })}\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default SortingVisualizer;","import React from 'react';\r\n\r\nimport './NavBar.css';\r\n\r\nimport Home from '../Home/Home';\r\nimport PathfindingVisualizer from '../PathfindingVisualizer/PathfindingVisualizer';\r\nimport SortingVisualizer from '../SortingVisualizer/SortingVisualizer';\r\n\r\n// Default tab to display on page load\r\nconst DEFAULT_TAB = \"Home\";\r\n\r\n/**\r\n * Represents the navigation bar at the top of the page. Each tab\r\n * contains one component of the project.\r\n * \r\n * @author Jake Waclawski\r\n */\r\nclass NavBar extends React.Component {\r\n    constructor (props) {\r\n        super(props);\r\n        this.state = { \r\n            // Currently displayed tab\r\n            curTab: DEFAULT_TAB,\r\n            // Is the expanded navigation bar expanded?\r\n            navigateExpandHidden: true,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Changes the currently displayed tab.\r\n     * \r\n     * @param {string} tab tab to change to\r\n     */\r\n    changeTab (tab) {\r\n        const elements = document.getElementsByClassName(\"tab-content\");\r\n        for (let i = 0; i < elements.length; i++) elements[i].style.display = \"none\";\r\n        document.getElementById(tab).style.display = \"block\";\r\n        this.setState({curTab: tab});\r\n    }\r\n\r\n    /**\r\n     * Runs on page load. Sets the current active tab.\r\n     */\r\n    componentDidMount () { document.getElementById(DEFAULT_TAB).style.display = \"block\"; }\r\n\r\n    /**\r\n     * Renders the navigation bar.\r\n     * \r\n     * @returns a <div> element representing the navigation bar\r\n     */\r\n    render () {\r\n        return (\r\n            <div>\r\n                <div className=\"topmenu\">\r\n                    <div className=\"topmenu-curtab\" \r\n                    onMouseEnter={() => this.setState({navigateExpandHidden: false})}>\r\n                    <span>{this.state.curTab}</span>\r\n                        <div className=\"topmenu-tablist topmenu-tablist-animate\"\r\n                        hidden={this.state.navigateExpandHidden}>\r\n                            <div className=\"topmenu-tab\"\r\n                            onClick={() => this.changeTab(\"Home\")}\r\n                            >Home</div>\r\n                            <div className=\"topmenu-tab\"\r\n                            onClick={() => this.changeTab(\"Pathfinding Visualizer\")}\r\n                            >Pathfinding Visualizer</div>\r\n                            <div className=\"topmenu-tab\"\r\n                            onClick={() => this.changeTab(\"Sorting Visualizer\")}\r\n                            >Sorting Visualizer</div>\r\n                        </div>\r\n                    </div>\r\n                </div>\r\n                <div>\r\n                    <div id=\"Home\" className=\"tab-content\">\r\n                        <Home changeTab={(tab) => this.changeTab(tab)}/>\r\n                    </div>\r\n                    <div id=\"Pathfinding Visualizer\" className=\"tab-content\">\r\n                        <PathfindingVisualizer />\r\n                    </div>\r\n                    <div id=\"Sorting Visualizer\" className=\"tab-content\">\r\n                        <SortingVisualizer />\r\n                    </div>\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default NavBar;","import './App.css';\r\nimport NavBar from './NavBar/NavBar';\r\n\r\nfunction App() {\r\n  return (\r\n    <div className=\"App\">\r\n      <NavBar></NavBar>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","const reportWebVitals = onPerfEntry => {\r\n  if (onPerfEntry && onPerfEntry instanceof Function) {\r\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\r\n      getCLS(onPerfEntry);\r\n      getFID(onPerfEntry);\r\n      getFCP(onPerfEntry);\r\n      getLCP(onPerfEntry);\r\n      getTTFB(onPerfEntry);\r\n    });\r\n  }\r\n};\r\n\r\nexport default reportWebVitals;\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport App from './App';\r\nimport reportWebVitals from './reportWebVitals';\r\n\r\nimport 'bootstrap/dist/css/bootstrap.min.css';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n\r\n// If you want to start measuring performance in your app, pass a function\r\n// to log results (for example: reportWebVitals(console.log))\r\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\r\nreportWebVitals();\r\n"],"sourceRoot":""}