{"version":3,"sources":["Home.js","utils.js","PathfindingVisualizer/PathfindAlgorithms.js","PathfindingVisualizer/MazeAlgorithms.js","PathfindingVisualizer/Node.js","PathfindingVisualizer/PathfindMenu.js","PathfindingVisualizer/PathfindingVisualizer.js","SortingVisualizer/SortAlgorithms.js","SortingVisualizer/SortMenu.js","SortingVisualizer/SortingVisualizer.js","NavBar.js","App.js","reportWebVitals.js","index.js"],"names":["Home","props","state","Card","CardHeader","href","CardBody","React","Component","random","min","max","Math","floor","QElement","element","priority","this","PriorityQueue","items","i","length","has","contains","splice","enqueue","qElement","contain","push","isEmpty","shift","str","pathfindAlgorithms","dijkstra","grid","start","target","visitedNodes","unvisitedNodes","nodes","row","node","getAllNodes","distance","sort","a","b","curNode","isWall","Infinity","isVisited","unvisitedNeighbors","getUnvisitedNeighbors","neighbor","cost","previousNode","neighbors","col","filter","mazeAlgorithms","recursiveDevision","rows","cols","walls","r","c","innerWalls","buildWalls","h","minC","maxC","minR","maxR","rGap","cGap","addVWall","addHWall","numHoles","holes","hole","includes","Node","nodeType","type","isStart","isTarget","id","className","onMouseDown","mousePressed","onMouseEnter","mouseEntered","onMouseLeave","mouseLeft","onAnimationEnd","animationEnded","PathfindMenu","curAlgorithm","mazeDropdownHidden","clearDropdownHidden","algorithmDropdownHidden","pathfindDropdownHidden","drawMode","document","getElementById","pathfinder","setDrawMode","setState","hidden","onClick","animateMaze","clearGrid","clearWalls","clearWeights","clearPaths","resetStartTarget","visualizePathfind","keyNodePressed","keyAnimationEnded","getCurrentAlgorithmText","ROW_COUNT","COL_COUNT","INIT_START","INIT_TARGET","nodeTypes","PathfindingVisualizer","weightCost","mouseIsDown","interactable","drawWall","drawWeight","startNode","targetNode","curRow","createNode","oldGrid","curVisual","rootDistance","getNodeVisual","curStart","updateNodeVisual","curTarget","isWeight","isInstant","updateGridState","updateAlgorithmInfo","initStart","initTarget","drawStartNode","drawTargetNode","weight","mode","algorithm","speed","softRebuildGrid","dequeue","manhattanD","abs","minDistance","setPriority","aStar","breadthFirstSearch","pop","depthFirstSearch","shortestPath","nodesInShortestPath","currentNode","unshift","getShortestPathNodes","totalCost","getShortestPathCost","animateSearch","drawVisitedNode","animatePath","setTimeout","drawPathNode","pathNodes","innerHTML","maze","randomWallMaze","randomWeightMaze","rNum","randomWallWeightMaze","drawWeightNode","drawWallNode","rebuildGrid","isPreview","onMouseUp","handleMouseUp","onContextMenu","e","preventDefault","onDragStart","Array","from","map","rowIdx","nodeIdx","handleMouseDown","handleMouseEnter","handleMouseLeft","handleAnimationEnd","UNSORTED","COMPARE","SORTED","SWAP","MIN","sortAlgorithms","mergeSort","array","animations","doMergeSort","middle","left","right","merge","SortMenu","visualizeDropdownOpen","Container","Row","Col","ButtonDropdown","isOpen","toggle","toggleVisualize","Button","color","DropdownToggle","split","DropdownMenu","DropdownItem","sorter","visualizeSort","reGenerateArray","SortingVisualizer","size","createBar","rebuildArray","bars","getElementsByClassName","style","backgroundColor","newMin","k","temp","selectionSort","cur","j","insertionSort","animateSort","step","action","height","bar","barIdx","NavBar","activeTab","Nav","tabs","NavItem","NavLink","classnames","active","TabContent","TabPane","tabId","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.421d74db.chunk.js","sourcesContent":["import React from 'react';\r\nimport { Card, CardHeader, CardBody\r\n} from 'reactstrap';\r\n\r\n/**\r\n * Represents the home tab component.\r\n * \r\n * @author Jake Waclawski\r\n */\r\nclass Home extends React.Component {\r\n    constructor (props) {\r\n        super(props);\r\n        this.state = {};\r\n    }\r\n\r\n    /**\r\n     * Renders the home tab component.\r\n     * \r\n     * @returns a <div> element representing the component\r\n     */\r\n    render () {\r\n        return (\r\n            <div>\r\n                <Card>\r\n                    <CardHeader>\r\n                        Jake Waclawski<br></br>\r\n                        <a href=\"https://github.com/jmw3638/Pathfinder\">GitHub</a>\r\n                    </CardHeader>\r\n                    <CardBody>\r\n                    </CardBody>\r\n                </Card>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default Home;","/**\r\n * Generates a random integer between two given values.\r\n * \r\n * @param {int} min minimum value\r\n * @param {int} max maximum value \r\n * \r\n * @returns the generated integer\r\n */\r\nexport function random(min, max) { return Math.floor(Math.random() * (max - min + 1) + min); }\r\n\r\n/**\r\n * User defined PriorityQueue helper class. Stores element and its priority.\r\n */\r\nclass QElement { \r\n    constructor(element, priority) \r\n    { \r\n        this.element = element; \r\n        this.priority = priority; \r\n    } \r\n} \r\n  \r\n/**\r\n * Represents a priority queue data structure.\r\n */\r\nclass PriorityQueue { \r\n    constructor() { \r\n        this.items = []; \r\n    } \r\n  \r\n    /**\r\n     * Determines if an element is in the priority queue.\r\n     * \r\n     * @param {Object} element element to search for\r\n     * \r\n     * @returns the index of the element, false if not found\r\n     */\r\n    contains(element) {\r\n        for (var i = 0; i < this.items.length; i++) {\r\n            if(this.items[i].element === element) return i;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Sets an element's priority.\r\n     * \r\n     * @param {Object} element the element\r\n     * @param {int} priority new priority\r\n     */\r\n    setPriority(element, priority) {\r\n        var has = this.contains(element);\r\n        if(!has) return;\r\n        this.items.splice(has, 1);\r\n        this.enqueue(element, priority);\r\n    }\r\n\r\n    /**\r\n     * Adds an element to the priority queue with a given priority.\r\n     * \r\n     * @param {Object} element \r\n     * @param {int} priority \r\n     */\r\n    enqueue(element, priority) \r\n    { \r\n        var qElement = new QElement(element, priority); \r\n        var contain = false; \r\n\r\n        for (var i = 0; i < this.items.length; i++) { \r\n            if (this.items[i].priority > qElement.priority) { \r\n                this.items.splice(i, 0, qElement); \r\n                contain = true; \r\n                break; \r\n            } \r\n        } \r\n\r\n        if (!contain) this.items.push(qElement);  \r\n    } \r\n\r\n    /**\r\n     * Removes and returns the first element from the priority queue.\r\n     * \r\n     * @returns the removed element, false if the queue is empty\r\n     */\r\n    dequeue() \r\n    { \r\n        if (this.isEmpty()) return false; \r\n        return this.items.shift(); \r\n    } \r\n\r\n\r\n    /**\r\n     * Returns the highest priority element in the queue without removing it.\r\n     * \r\n     * @returns highest priority element, false if empty\r\n     */\r\n    front() \r\n    { \r\n        if (this.isEmpty()) return false; \r\n        return this.items[0]; \r\n    } \r\n\r\n    /**\r\n     * Returns the lowest priority element in the queue without removing it.\r\n     * \r\n     * @returns lowest priority element, false if empty\r\n     */\r\n    rear() \r\n    {  \r\n        if (this.isEmpty()) return false; \r\n        return this.items[this.items.length - 1]; \r\n    } \r\n\r\n    /**\r\n     * Determines if the priority queue is empty or not.\r\n     * \r\n     * @returns if the priority queue is empty\r\n     */\r\n    isEmpty() { return this.items.length === 0; } \r\n\r\n\r\n    /**\r\n     * Prints all elements of the priority queue.\r\n     * \r\n     * @returns the generated print string\r\n     */\r\n    printPQueue() \r\n    { \r\n        var str = \"\"; \r\n        for (var i = 0; i < this.items.length; i++) str += this.items[i].element + \" \"; \r\n        return str; \r\n    } \r\n} \r\n\r\nexport default PriorityQueue;","import PriorityQueue from \"../utils\";\r\n\r\n// Pathfinding algorithms\r\nexport const pathfindAlgorithms = {\r\n    DIJKSTRA: \"Dijkstra\",\r\n    ASTAR: \"A-Star\",\r\n    BFS: \"Breadth First Search\",\r\n    DFS: \"Depth First Search\",\r\n}\r\n\r\n/**\r\n * Executes a Dijkstra's algorithm search.\r\n * \r\n * @param {Array} grid grid of nodes\r\n * @param {Object} start start node\r\n * @param {Object} target target node\r\n * \r\n * @returns an array of visited nodes in order\r\n */\r\nexport function dijkstra(grid, start, target) {\r\n    const visitedNodes = [];\r\n    const unvisitedNodes = getAllNodes(grid);\r\n    start.distance = 0;\r\n    while (unvisitedNodes.length !== 0) {\r\n        unvisitedNodes.sort((a, b) => a.distance - b.distance);\r\n        const curNode = unvisitedNodes.shift();\r\n        \r\n        if (!curNode) break;\r\n        if (curNode.isWall) continue;\r\n\r\n        if (curNode.distance === Infinity) return visitedNodes;\r\n\r\n        curNode.isVisited = true;\r\n        visitedNodes.push(curNode);\r\n\r\n        if (curNode === target) return visitedNodes;\r\n\r\n        const unvisitedNeighbors = getUnvisitedNeighbors(curNode, grid);\r\n        for (const neighbor of unvisitedNeighbors) {\r\n            neighbor.distance = curNode.distance + neighbor.cost;\r\n            neighbor.previousNode = curNode;\r\n        }\r\n    }\r\n    return visitedNodes;\r\n}\r\n\r\n/**\r\n * Executes an A* (A-Star) algorithm search.\r\n * \r\n * @param {Array} grid grid of nodes\r\n * @param {Object} start start node\r\n * @param {Object} target target node\r\n * \r\n * @returns an array of visited nodes in order\r\n */\r\nexport function aStar(grid, start, target) {\r\n    const visitedNodes = [];\r\n    const unvisitedNodes = new PriorityQueue();\r\n    unvisitedNodes.enqueue(start, 0);\r\n    start.distance = 0;\r\n    start.rootDistance = 0;\r\n    while (!unvisitedNodes.isEmpty()) {\r\n        const curNode = unvisitedNodes.dequeue().element;\r\n\r\n        if (curNode.isWall) continue;\r\n\r\n        if (curNode.distance === Infinity) return visitedNodes;\r\n\r\n        curNode.isVisited = true;\r\n        visitedNodes.push(curNode);\r\n\r\n        if (curNode === target) return visitedNodes;\r\n\r\n        const unvisitedNeighbors = getUnvisitedNeighbors(curNode, grid);\r\n        for (const neighbor of unvisitedNeighbors) {\r\n            const manhattanD = 2 * (Math.abs(target.row - neighbor.row) + (Math.abs(target.col - neighbor.col)));\r\n            neighbor.rootDistance = Math.min(neighbor.rootDistance, curNode.rootDistance + neighbor.cost);\r\n            const minDistance = Math.min(neighbor.distance, neighbor.rootDistance + manhattanD);\r\n            if (minDistance !== neighbor.distance) {\r\n                neighbor.distance = minDistance;\r\n                neighbor.previousNode = curNode;\r\n                if (unvisitedNodes.contains(neighbor)) unvisitedNodes.setPriority(neighbor, minDistance);\r\n            }\r\n            if (!unvisitedNodes.contains(neighbor)) unvisitedNodes.enqueue(neighbor, neighbor.distance);\r\n        }\r\n    }\r\n    return visitedNodes;\r\n}\r\n\r\n/**\r\n * Executes Breadth First Search (BFS) algorithm search.\r\n * \r\n * @param {Array} grid grid of nodes\r\n * @param {Object} start start node\r\n * @param {Object} target target node\r\n * \r\n * @returns an array of visited nodes in order\r\n */\r\nexport function breadthFirstSearch(grid, start, target) {\r\n    const visitedNodes = [];\r\n    const unvisitedNodes = [start];\r\n    start.distance = 0;\r\n    while (unvisitedNodes.length !== 0) {\r\n        const curNode = unvisitedNodes.shift();\r\n\r\n        if (curNode.isWall) continue;\r\n        if (curNode.isVisited) continue;\r\n\r\n        if (curNode.distance === Infinity) return visitedNodes;\r\n\r\n        curNode.isVisited = true;\r\n        visitedNodes.push(curNode);\r\n\r\n        if (curNode === target) return visitedNodes; \r\n\r\n        const unvisitedNeighbors = getUnvisitedNeighbors(curNode, grid);\r\n        for (const neighbor of unvisitedNeighbors) {\r\n            unvisitedNodes.push(neighbor);\r\n            \r\n\r\n            neighbor.distance = curNode.distance + 1;\r\n            neighbor.previousNode = curNode;\r\n        }\r\n    }\r\n    return visitedNodes;\r\n}\r\n\r\n/**\r\n * Executes a Depth First Search (DFS) algorithm search.\r\n * \r\n * @param {Array} grid grid of nodes\r\n * @param {Object} start start node\r\n * @param {Object} target target node\r\n * \r\n * @returns an array of visited nodes in order\r\n */\r\nexport function depthFirstSearch(grid, start, target) {\r\n    const visitedNodes = [];\r\n    const unvisitedNodes = [start];\r\n    start.distance = 0;\r\n    while (unvisitedNodes.length !== 0) {\r\n        const curNode = unvisitedNodes.pop();\r\n\r\n        if (curNode.isWall) continue;\r\n        if (curNode.isVisited) continue;\r\n\r\n        if (curNode.distance === Infinity) return visitedNodes;\r\n        if (curNode === target) return visitedNodes;\r\n\r\n        const unvisitedNeighbors = getUnvisitedNeighbors(curNode, grid);\r\n        for (const neighbor of unvisitedNeighbors) {\r\n            unvisitedNodes.push(neighbor);\r\n            curNode.isVisited = true;\r\n            visitedNodes.push(curNode);\r\n\r\n            neighbor.distance = curNode.distance + 1;\r\n            neighbor.previousNode = curNode;\r\n        }\r\n    }\r\n    return visitedNodes;\r\n}\r\n\r\n/**\r\n * Gets all of the nodes in the grid.\r\n * \r\n * @param {Array} grid grid of nodes\r\n * \r\n * @returns an array containing all of the nodes\r\n */\r\nfunction getAllNodes(grid) {\r\n    const nodes = [];\r\n    for (const row of grid) {\r\n        for (const node of row) nodes.push(node);\r\n    }\r\n    return nodes;\r\n}\r\n\r\n/**\r\n * Gets the shortest path of nodes from the target node to \r\n * the start node.\r\n * \r\n * @param {Object} targetNode target node\r\n * \r\n * @returns an array of shortest path nodes in order\r\n */\r\nexport function getShortestPathNodes(targetNode) {\r\n    const nodesInShortestPath = [];\r\n    let currentNode = targetNode;\r\n    while (currentNode !== null) {\r\n        nodesInShortestPath.unshift(currentNode);\r\n        currentNode = currentNode.previousNode;\r\n    }\r\n    return nodesInShortestPath;\r\n}\r\n\r\n/**\r\n * Gets the total weighted cost of the shortest path.\r\n * \r\n * @param {Object} targetNode target node\r\n * \r\n * @returns the total cost\r\n */\r\nexport function getShortestPathCost(targetNode) {\r\n    const nodesInShortestPath = [];\r\n    let currentNode = targetNode;\r\n    let totalCost = 0;\r\n    while (currentNode !== null) {\r\n        nodesInShortestPath.unshift(currentNode);\r\n        totalCost += currentNode.cost;\r\n        currentNode = currentNode.previousNode;\r\n    }\r\n    return totalCost;\r\n}\r\n\r\n/**\r\n * Gets all unvisited neighbors of a given node.\r\n * \r\n * @param {Object} node node\r\n * @param {Array} grid grid of nodes\r\n * \r\n * @returns an array containing all unvisited neighbors\r\n */\r\nfunction getUnvisitedNeighbors(node, grid) {\r\n    const neighbors = [];\r\n    const {row, col} = node;\r\n    \r\n    if (col > 0) neighbors.push(grid[row][col - 1]); // West\r\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]); // South\r\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]); // East\r\n    if (row > 0) neighbors.push(grid[row - 1][col]); // North\r\n    \r\n    return neighbors.filter(neighbor => !neighbor.isVisited);\r\n}","import { random } from '../utils';\r\n\r\n// Maze algorithms\r\nexport const mazeAlgorithms = {\r\n    RECURSIVE_DEVISION: \"Recursive Devision\",\r\n    RANDOM_WALL: \"Random Wall\",\r\n    RANDOM_WEIGHT: \"Random Weight\",\r\n    RANDOM_WALL_WEIGHT: \"Random Wall/Weight\"\r\n}\r\n\r\n/**\r\n * Algorithm for generating a random wall maze.\r\n * \r\n * @param {int} rows number of rows\r\n * @param {int} cols number of columns\r\n * \r\n * @returns a grid of boolean values, true if wall node\r\n */\r\nexport function randomWallMaze(rows, cols) {\r\n    var walls = []\r\n\r\n    for (let r = 0; r < rows; r++) {\r\n        for (let c = 0; c < cols; c++) {\r\n            const rNum = random(1, 10);\r\n            if (rNum <= 3) walls.push([r, c]);\r\n        }\r\n    }\r\n\r\n    return walls;\r\n}\r\n\r\n/**\r\n * Algorithm for generating a random weight maze.\r\n * \r\n * @param {int} rows number of rows\r\n * @param {int} cols number of columns\r\n * \r\n * @returns a grid of boolean values, true if wall node\r\n */\r\nexport function randomWeightMaze(rows, cols) {\r\n    var walls = []\r\n\r\n    for (let r = 0; r < rows; r++) {\r\n        for (let c = 0; c < cols; c++) {\r\n            const rNum = random(1, 10);\r\n            if (rNum <= 3) walls.push([r, c, true]);\r\n        }\r\n    }\r\n\r\n    return walls;\r\n}\r\n\r\n/**\r\n * Algorithm for generating a random wall/weight maze.\r\n * \r\n * @param {int} rows number of rows\r\n * @param {int} cols number of columns\r\n * \r\n * @returns a grid of boolean values, true if wall node\r\n */\r\nexport function randomWallWeightMaze(rows, cols) {\r\n    var walls = []\r\n\r\n    for (let r = 0; r < rows; r++) {\r\n        for (let c = 0; c < cols; c++) {\r\n            const rNum = random(1, 10);\r\n            if (rNum <= 2) walls.push([r, c]);\r\n            if (rNum >= 8) walls.push([r, c, true]);\r\n        }\r\n    }\r\n\r\n    return walls;\r\n}\r\n\r\n/**\r\n * Algorithm for generating a maze using recursive devision.\r\n * \r\n * @param {int} rows number of rows\r\n * @param {int} cols number of columns\r\n * \r\n * @returns a grid of boolean values, true if wall node\r\n */\r\nexport function recursiveDevision(rows, cols) {\r\n    var walls = [];\r\n\r\n    //walls = innerWalls(walls, true, 0, cols-1, 0, rows-1);\r\n    walls = buildWalls(walls, rows, cols);\r\n    \r\n    return walls;\r\n}\r\n\r\n/**\r\n * Creates walls around the border of the maze.\r\n * \r\n * @param {Array} walls grid of walls\r\n * @param {int} rows amount of rows \r\n * @param {int} cols amount of columns\r\n * \r\n * @returns a grid of walls\r\n */\r\nfunction buildWalls(walls, rows, cols) {\r\n    for (var r = 0; r < rows; r++) {\r\n        if (r === 0 || r === (rows-1)) {\r\n            for (var c = 0; c < cols; c++) {\r\n                walls.push([r, c]);\r\n            }\r\n        } else {\r\n            walls.push([r, 0]);\r\n            walls.push([r, cols-1]);\r\n        }\r\n    }\r\n\r\n    walls = innerWalls(walls, random(0, 1), 1, cols-2, 1, rows-2);\r\n    return walls;\r\n}\r\n\r\n/**\r\n * Recursive function that builds the inner walls of the maze.\r\n * \r\n * @param {Array} walls grid of walls\r\n * @param {boolean} h is horizontal wall\r\n * @param {int} minC lower column bound\r\n * @param {int} maxC upper column bound\r\n * @param {int} minR lower row bound\r\n * @param {int} maxR upper row bound\r\n * \r\n * @returns a grid of walls\r\n */\r\nfunction innerWalls(walls, h, minC, maxC, minR, maxR) {\r\n    const rGap = maxR - minR;\r\n    const cGap = maxC - minC;\r\n\r\n    if (maxR - minR <= 1) return walls; \r\n    if (maxC - minC <= 1) return walls; \r\n\r\n    var r = Math.floor(random(minR+1, maxR-1)/2)*2;\r\n    var c = Math.floor(random(minC+1, maxC-1)/2)*2;\r\n\r\n    // ^ xor: one or the other but not both\r\n    if (rGap <= 5 ^ cGap<= 5) {\r\n        if (rGap <= 5) {\r\n            walls = addVWall(walls, minR, maxR, c);\r\n\r\n            walls = innerWalls(walls, !h, minC, c-1, minR, maxR);\r\n            walls = innerWalls(walls, !h, c+1, maxC, minR, maxR);\r\n        }\r\n        if (cGap <= 5) {\r\n            walls = addHWall(walls, minC, maxC, r);\r\n    \r\n            walls = innerWalls(walls, !h, minC, maxC, minR, r-1);\r\n            walls = innerWalls(walls, !h, minC, maxC, r+1, maxR);\r\n        }\r\n        return walls;\r\n    } \r\n    if (h) {\r\n        walls = addHWall(walls, minC, maxC, r);\r\n\r\n        walls = innerWalls(walls, !h, minC, maxC, minR, r-1);\r\n        walls = innerWalls(walls, !h, minC, maxC, r+1, maxR);\r\n    } else {\r\n        walls = addVWall(walls, minR, maxR, c);\r\n\r\n        walls = innerWalls(walls, !h, minC, c-1, minR, maxR);\r\n        walls = innerWalls(walls, !h, c+1, maxC, minR, maxR);\r\n    }\r\n    return walls;\r\n}\r\n\r\n/**\r\n * Builds a horizontal wall at a given row.\r\n * \r\n * @param {Array} walls grid of walls\r\n * @param {int} minC lower column bound\r\n * @param {int} maxC upper column bound\r\n * @param {int} r row\r\n */\r\nfunction addHWall(walls, minC, maxC, r) {\r\n    const numHoles = random(1, (maxC - minC)/4);\r\n    const holes = [];\r\n    for (let i = 0; i < numHoles; i++) {\r\n        const hole = Math.floor(random(minC, maxC)/2)*2+1;\r\n        holes.push(hole);\r\n    }\r\n\r\n    for (var i = minC; i <= maxC; i++) if (!holes.includes(i)) walls.push([r, i]); \r\n    return walls;\r\n}\r\n\r\n/**\r\n * Builds a vertical wall at a given column.\r\n * \r\n * @param {Array} walls grid of walls\r\n * @param {int} minR lower row bound\r\n * @param {int} maxR upper row bound\r\n * @param {int} c column \r\n */\r\nfunction addVWall(walls, minR, maxR, c) {\r\n    const numHoles = random(1, (maxR - minR)/4);\r\n    const holes = [];\r\n    for (let i = 0; i < numHoles; i++) {\r\n        const hole = Math.floor(random(minR, maxR)/2)*2+1;\r\n        holes.push(hole);\r\n    }\r\n\r\n    for (var i = minR; i <= maxR; i++) if (!holes.includes(i)) walls.push([i, c]); \r\n    return walls;\r\n}","import React from 'react';\r\n\r\nimport './Node.css';\r\n\r\n/**\r\n * Represents a grid node on the screen. Extra class names\r\n * can be applied to change the appearance of the node.\r\n * \r\n * @author Jake Waclawski\r\n */\r\nclass Node extends React.Component {\r\n    constructor (props) {\r\n        super(props);\r\n        this.state = {};\r\n    }\r\n\r\n    /**\r\n     * Renders the node.\r\n     * \r\n     * @returns a <div> element representing the node\r\n     */\r\n    render () {\r\n        const nodeType = this.props.type ? this.props.type :\r\n        this.props.isStart ? 'start' : \r\n        this.props.isTarget ? 'target' : \r\n        '';\r\n\r\n        return (\r\n            <div \r\n            id={`node-${this.props.row}-${this.props.col}`} \r\n            className={`node ${nodeType}`}\r\n            onMouseDown={() => this.props.mousePressed(this.props.row, this.props.col)}\r\n            onMouseEnter={() => this.props.mouseEntered(this.props.row, this.props.col)}\r\n            onMouseLeave={() => this.props.mouseLeft(this.props.row, this.props.col)}\r\n            onAnimationEnd={() => this.props.animationEnded(nodeType)}\r\n            /> \r\n        );\r\n    }\r\n}\r\n\r\nexport default Node;","import React from 'react';\r\n\r\nimport Node from './Node';\r\nimport { pathfindAlgorithms } from './PathfindAlgorithms';\r\nimport { mazeAlgorithms } from './MazeAlgorithms';\r\n\r\n/**\r\n * Represents the top menu of the pathfinding visualizer component.\r\n * \r\n * @author Jake Waclawski\r\n */\r\nclass PathfindMenu extends React.Component {\r\n    constructor (props) {\r\n        super(props);\r\n        this.state = {\r\n            // Currently selected pathfinding algorithm\r\n            curAlgorithm: null,\r\n            // Is the maze button dropdown open?\r\n            mazeDropdownHidden: true,\r\n            // Is the clear button dropdown open?\r\n            clearDropdownHidden: true,\r\n            // Is the algorithm button dropdown open?\r\n            algorithmDropdownHidden: true,\r\n            // Is the pathfind button dropdown open?\r\n            pathfindDropdownHidden: true,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets the current algorithm for the information text as a string.\r\n     * \r\n     * @returns the string\r\n     */\r\n    getCurrentAlgorithmText() {\r\n        if (!this.state.curAlgorithm) return \"None\";\r\n        return this.state.curAlgorithm;\r\n    }\r\n\r\n    /**\r\n     * Runs the animation for the pressed node. Sets the appropriate draw mode.\r\n     * \r\n     * @param {string} id element id\r\n     * @param {string} className class name to set\r\n     * @param {int} drawMode draw mode to set\r\n     */\r\n    keyNodePressed (id, className, drawMode) {\r\n        document.getElementById(`node-${id}`).className = className;\r\n        if (drawMode || drawMode === 0) this.props.pathfinder.setDrawMode(drawMode);\r\n    }\r\n\r\n    /**\r\n     * Reverts the node state to the instant version.\r\n     * \r\n     * @param {string} id node element id\r\n     * @param {string} className class name to set\r\n     */\r\n    keyAnimationEnded (id, className) { document.getElementById(`node-${id}`).className = `node ${className}`; }\r\n    \r\n    /**\r\n     * Renders the menu component.\r\n     * \r\n     * @returns a <div> element representing the menu\r\n     */\r\n    render () {\r\n        return (\r\n            <div className=\"pathfind-menu\">\r\n                <div className=\"pv-menu-bar\">\r\n                    <div className=\"pv-title\">Pathfinding Visualizer</div>\r\n                    <div className=\"maze-dropdown dropdown-animate\">\r\n                        <div className=\"pv-menu-bar-button\" \r\n                        onMouseEnter={() => this.setState({mazeDropdownHidden: false})}>\r\n                        <span>Maze</span></div>\r\n                        <div className=\"pv-menu-dropdown-content maze-drop-content dropdown-animate\"\r\n                        hidden={this.state.mazeDropdownHidden}\r\n                        onClick={() => this.setState({mazeDropdownHidden: true})}>\r\n                            <div className=\"pv-menu-dropdown-content-item\"\r\n                            onClick={() => this.props.pathfinder.animateMaze(mazeAlgorithms.RECURSIVE_DEVISION)}\r\n                            >Recursive Devision</div>\r\n                            <div className=\"pv-menu-dropdown-content-item\"\r\n                            onClick={() => this.props.pathfinder.animateMaze(mazeAlgorithms.RANDOM_WALL)}\r\n                            >Random Wall</div>\r\n                            <div className=\"pv-menu-dropdown-content-item\"\r\n                            onClick={() => this.props.pathfinder.animateMaze(mazeAlgorithms.RANDOM_WEIGHT)}\r\n                            >Random Weight</div>\r\n                            <div className=\"pv-menu-dropdown-content-item\"\r\n                            onClick={() => this.props.pathfinder.animateMaze(mazeAlgorithms.RANDOM_WALL_WEIGHT)}\r\n                            >Random Wall/Weight</div>\r\n                        </div>\r\n                    </div>\r\n                    <div className=\"clear-dropdown dropdown-animate\">\r\n                        <div className=\"pv-menu-bar-button\" \r\n                        onClick={() => this.props.pathfinder.clearGrid()}\r\n                        onMouseEnter={() => this.setState({clearDropdownHidden: false})}>\r\n                        <span>Clear</span></div>\r\n                        <div className=\"pv-menu-dropdown-content clear-drop-content dropdown-animate\"\r\n                        hidden={this.state.clearDropdownHidden} \r\n                        onClick={() => this.setState({clearDropdownHidden: true})}>\r\n                            <div className=\"pv-menu-dropdown-content-item\"\r\n                            onClick={() => this.props.pathfinder.clearWalls()}\r\n                            >Clear Walls</div>\r\n                            <div className=\"pv-menu-dropdown-content-item\"\r\n                            onClick={() => this.props.pathfinder.clearWeights()}\r\n                            >Clear Weights</div>\r\n                            <div className=\"pv-menu-dropdown-content-item\"\r\n                            onClick={() => this.props.pathfinder.clearPaths()}\r\n                            >Clear Path</div>\r\n                            <div className=\"pv-menu-dropdown-content-item\"\r\n                            onClick={() => this.props.pathfinder.resetStartTarget()}\r\n                            >Reset Start/Target</div>\r\n                        </div>\r\n                    </div>\r\n                    <div className=\"algorithm-dropdown dropdown-animate\">\r\n                        <div className=\"pv-menu-bar-button\"\r\n                        onMouseEnter={() => this.setState({algorithmDropdownHidden: false})}\r\n                        onClick={() => this.setState({curAlgorithm: null})}>\r\n                        <span>Algorithm</span></div>\r\n                        <div className=\"pv-menu-dropdown-content alg-drop-content dropdown-animate\"\r\n                        hidden={this.state.algorithmDropdownHidden} \r\n                        onClick={() => this.setState({algorithmDropdownHidden: true})}>\r\n                            <div className=\"pv-menu-dropdown-content-item\"\r\n                            onClick={() => this.setState({curAlgorithm: pathfindAlgorithms.DIJKSTRA})}\r\n                            >Dijkstra</div>\r\n                            <div className=\"pv-menu-dropdown-content-item\"\r\n                            onClick={() => this.setState({curAlgorithm: pathfindAlgorithms.ASTAR})}\r\n                            >A* (A-Star)</div>\r\n                            <div className=\"pv-menu-dropdown-content-item\"\r\n                            onClick={() => this.setState({curAlgorithm: pathfindAlgorithms.BFS})}\r\n                            >Breadth First Search</div>\r\n                            <div className=\"pv-menu-dropdown-content-item\"\r\n                            onClick={() => this.setState({curAlgorithm: pathfindAlgorithms.DFS})}\r\n                            >Depth First Search</div>\r\n                        </div>\r\n                    </div>\r\n                    <div className=\"pathfind-dropdown dropdown-animate\">\r\n                        <div className=\"pv-menu-bar-button\" \r\n                        onMouseEnter={() => this.setState({pathfindDropdownHidden: false})}\r\n                        onClick={() => this.props.pathfinder.visualizePathfind(this.state.curAlgorithm)}>\r\n                        <span>Pathfind</span></div>\r\n                        <div className=\"pv-menu-dropdown-content pathfind-drop-content dropdown-animate\"\r\n                        hidden={this.state.pathfindDropdownHidden}\r\n                        onClick={() => this.setState({pathfindDropdownHidden: true})}>\r\n                            <div className=\"pv-menu-dropdown-content-item\"\r\n                            onClick={() => this.props.pathfinder.visualizePathfind(this.state.curAlgorithm, 250)}\r\n                            >Very Slow</div>\r\n                            <div className=\"pv-menu-dropdown-content-item\"\r\n                            onClick={() => this.props.pathfinder.visualizePathfind(this.state.curAlgorithm, 100)}\r\n                            >Slow</div>\r\n                            <div className=\"pv-menu-dropdown-content-item\"\r\n                            onClick={() => this.props.pathfinder.visualizePathfind(this.state.curAlgorithm, 25)}\r\n                            >Fast</div>\r\n                            <div className=\"pv-menu-dropdown-content-item\"\r\n                            onClick={() => this.props.pathfinder.visualizePathfind(this.state.curAlgorithm, 5)}\r\n                            >Very Fast</div>\r\n                            <div className=\"pv-menu-dropdown-content-item\"\r\n                            onClick={() => this.props.pathfinder.visualizePathfind(this.state.curAlgorithm, 0)}\r\n                            >Instant</div>\r\n                        </div>\r\n                    </div>\r\n                </div>\r\n                <div className=\"pathfind-key\">\r\n                    <div className=\"key-item\" onClick={() => this.keyNodePressed(\"start-instant\", \"node start\", 3)}>\r\n                        <div className=\"key-node\">\r\n                            <Node type={\"start-instant\"}\r\n                            row={\"start\"}\r\n                            col={\"instant\"}\r\n                            animationEnded={(type) => this.keyAnimationEnded(type, type)}\r\n                            mousePressed={() => null} mouseEntered={() => null} mouseLeft={() => null}/>\r\n                        </div>\r\n                        <div id='start-text' className=\"key-text\">Start Node</div>\r\n                    </div>\r\n                    <div className=\"key-item\" onClick={() => this.keyNodePressed(\"target-instant\", \"node target\", 4)}>\r\n                        <div className=\"key-node\">\r\n                            <Node type={\"target-instant\"}\r\n                            row={\"target\"}\r\n                            col={\"instant\"}\r\n                            animationEnded={(type) => this.keyAnimationEnded(type, type)}\r\n                            mousePressed={() => null} mouseEntered={() => null} mouseLeft={() => null}/>\r\n                        </div>\r\n                        <div className=\"key-text\">Target Node</div>\r\n                    </div>\r\n                    <div className=\"key-item\" onClick={() => this.keyNodePressed(\"weight-instant\", \"node weight\", 2)}>\r\n                        <div className=\"key-node\">\r\n                            <Node type={\"weight-instant\"}\r\n                            row={\"weight\"}\r\n                            col={\"instant\"}                           \r\n                            animationEnded={(type) => this.keyAnimationEnded(type, type)}\r\n                            mousePressed={() => null} mouseEntered={() => null} mouseLeft={() => null}/>\r\n                        </div>\r\n                        <div className=\"key-text\">Weighted Node</div>\r\n                    </div>\r\n                    <div className=\"key-item\" onClick={() => this.keyNodePressed(\"wall-instant\", \"node wall\", 1)}>\r\n                        <div className=\"key-node\">\r\n                            <Node type={\"wall-instant\"}\r\n                            row={\"wall\"}\r\n                            col={\"instant\"}\r\n                            animationEnded={(type) => this.keyAnimationEnded(type, type)}\r\n                            mousePressed={() => null} mouseEntered={() => null} mouseLeft={() => null}/>\r\n                        </div>\r\n                        <div className=\"key-text\">Wall Node</div>\r\n                    </div>\r\n                    <div className=\"key-item\" onClick={() => this.keyNodePressed(\"unvisited-instant\", \"node node-animated\", 0)}>\r\n                        <div className=\"key-node\">\r\n                            <Node type={\"unvisited-instant\"}\r\n                            row={\"unvisited\"}\r\n                            col={\"instant\"}\r\n                            animationEnded={(type) => this.keyAnimationEnded(type, \"node\")}\r\n                            mousePressed={() => null} mouseEntered={() => null} mouseLeft={() => null}/>\r\n                        </div>\r\n                        <div className=\"key-text\">Unvisited Node</div>\r\n                    </div>\r\n                    <div className=\"key-item\">\r\n                        <div className=\"key-node\" onClick={() => this.keyNodePressed(\"visited-instant\", \"node visited\")}>\r\n                            <Node type={\"visited-instant\"}\r\n                            row={\"visited\"}\r\n                            col={\"instant\"}\r\n                            animationEnded={(type) => this.keyAnimationEnded(type, type)}\r\n                            mousePressed={() => null} mouseEntered={() => null} mouseLeft={() => null}/>\r\n                        </div>\r\n                        <div className=\"key-node\" onClick={() => this.keyNodePressed(\"visited-weight-instant\", \"node visited-weight\")}>\r\n                            <Node type={\"visited-weight-instant\"}\r\n                            row={\"visited-weight\"}\r\n                            col={\"instant\"}\r\n                            animationEnded={(type) => this.keyAnimationEnded(type, type)}\r\n                            mousePressed={() => null} mouseEntered={() => null} mouseLeft={() => null}/>         \r\n                        </div>\r\n                        <div className=\"key-text\">Visited Nodes</div>\r\n                    </div>\r\n                    <div className=\"key-item\">\r\n                        <div className=\"key-node\" onClick={() => this.keyNodePressed(\"path-instant\", \"node path\")}>\r\n                            <Node type={\"path-instant\"}\r\n                            row={\"path\"}\r\n                            col={\"instant\"}\r\n                            animationEnded={(type) => this.keyAnimationEnded(type, type)}\r\n                            mousePressed={() => null} mouseEntered={() => null} mouseLeft={() => null}/>\r\n                        </div>\r\n                        <div className=\"key-node\" onClick={() => this.keyNodePressed(\"path-weight-instant\", \"node path-weight\")}>\r\n                            <Node type={\"path-weight-instant\"}\r\n                            row={\"path-weight\"}\r\n                            col={\"instant\"}\r\n                            animationEnded={(type) => this.keyAnimationEnded(type, type)}\r\n                            mousePressed={() => null} mouseEntered={() => null} mouseLeft={() => null}/>\r\n                        </div>\r\n                        <div className=\"key-text\">Path Nodes</div>\r\n                    </div>\r\n                </div>\r\n                <div className=\"pathfind-info\">\r\n                    <div className=\"info-item\">\r\n                        <div>Algorithm:</div>\r\n                        <div id=\"algorithm-info-text\" className=\"info-text\">{this.getCurrentAlgorithmText()}</div>\r\n                    </div>\r\n                    <div className=\"info-item\">\r\n                        <div>Visited Nodes:</div>\r\n                        <div id=\"visited-info-text\" className=\"info-text\">0</div>\r\n                    </div>\r\n                    <div className=\"info-item\">\r\n                        <div>Path Nodes:</div>\r\n                        <div id=\"path-info-text\" className=\"info-text\">No Path</div>\r\n                    </div>\r\n                    <div className=\"info-item\">\r\n                        <div>Path Cost:</div>\r\n                        <div id=\"weighted-info-text\" className=\"info-text\">0</div>\r\n                    </div>\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default PathfindMenu;","import React from 'react';\r\n\r\nimport './PathfindingVisualizer.css';\r\n\r\nimport { getShortestPathNodes, dijkstra, aStar, breadthFirstSearch, depthFirstSearch, pathfindAlgorithms, getShortestPathCost\r\n} from './PathfindAlgorithms';\r\nimport { recursiveDevision, mazeAlgorithms, randomWallMaze, randomWeightMaze, randomWallWeightMaze\r\n} from './MazeAlgorithms';\r\nimport PathfindMenu from './PathfindMenu';\r\nimport Node from './Node';\r\n\r\n// Number of rows in the grid\r\nconst ROW_COUNT = 29;\r\n// Number of columns in the grid\r\nconst COL_COUNT = 71;\r\n// Initial cost of weighted nodes\r\nconst INIT_COST = 15;\r\n// Initial coordinates of the start node [row, col]\r\nconst INIT_START = [14, 10];\r\n// Initial coordinates of the target noe [row, col]\r\nconst INIT_TARGET = [14, 60];\r\n// Speed between visited node animations in miliseconds\r\nconst VISITED_SPEED = 15;\r\n// Speed between shortest path node animations in miliseconds\r\nconst PATH_SPEED = 25;\r\n// Speed between maze wall node animations in miliseconds\r\nconst MAZE_SPEED = 10;\r\n\r\n// Node class types\r\nconst nodeTypes = {\r\n    NODE: 'node',\r\n    NODE_ANIMATED: 'node node-animated',\r\n    WALL: 'node wall',\r\n    WALL_INSTANT: 'node wall-instant',\r\n    WALL_PREVIEW: 'node wall-preview',\r\n    WEIGHT: 'node weight',\r\n    WEIGHT_INSTANT: 'node weight-instant',\r\n    WEIGHT_PREVIEW: 'node weight-preview',\r\n    START: 'node start',\r\n    START_INSTANT: 'node start-instant',\r\n    START_PREVIEW: 'node start-preview',\r\n    TARGET: 'node target',\r\n    TARGET_INSTANT: 'node target-instant',\r\n    TARGET_PREVIEW: 'node target-preview',\r\n    VISITED: 'node visited',\r\n    VISITED_INSTANT: 'node visited-instant',\r\n    VISITED_WEIGHT: 'node visited-weight',\r\n    VISITED_WEIGHT_INSTANT: 'node visited-weight-instant',\r\n    PATH: 'node path',\r\n    PATH_INSTANT: 'node path-instant',\r\n    PATH_WEIGHT: 'node path-weight',\r\n    PATH_WEIGHT_INSTANT: 'node path-weight-instant',\r\n}\r\n\r\n/**\r\n * Represents the pathfinding visualizer component.\r\n * \r\n * @author Jake Waclawski\r\n */\r\nclass PathfindingVisualizer extends React.Component {\r\n    constructor (props) {\r\n        super(props);\r\n        this.state = {\r\n            // Current state of grid nodes\r\n            grid: [],\r\n            // Current cost of weighted nodes\r\n            weightCost: INIT_COST,\r\n            // Is the mouse down?\r\n            mouseIsDown: false,\r\n            // Are we currently allowed to interact with the grid\r\n            interactable: true,\r\n            // Current draw mode (0: none, 1: walls, 2: weights)\r\n            drawMode: 0,\r\n            // Are we erasing or drawing walls (null if neither)?\r\n            drawWall: null,\r\n            // Are we erasing or drawing weights (null if neither)?\r\n            drawWeight: null,\r\n            // Current start node position\r\n            startNode: INIT_START,\r\n            // Current target node position\r\n            targetNode: INIT_TARGET,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the grid with new nodes. Start and target\r\n     * node positions are preserved.\r\n     */\r\n    rebuildGrid () {\r\n        const grid = [];\r\n        for (let r = 0; r < ROW_COUNT; r++) {\r\n            const curRow = [];\r\n            for (let c = 0; c < COL_COUNT; c++) {\r\n                const node = this.createNode(r, c, 1, false);\r\n                curRow.push(node);\r\n            }\r\n            grid.push(curRow);\r\n        }\r\n        this.setState({grid: grid});\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the grid with new nodes. Main node types are\r\n     * preserved (start, target, wall, weight).\r\n     */\r\n    softRebuildGrid () {\r\n        const oldGrid = this.state.grid;\r\n        const grid = [];\r\n        for (let r = 0; r < ROW_COUNT; r++) {\r\n            const curRow = [];\r\n            for (let c = 0; c < COL_COUNT; c++) {\r\n                const node = this.createNode(r, c, oldGrid[r][c].cost, oldGrid[r][c].isWall)\r\n                curRow.push(node);\r\n            }\r\n            grid.push(curRow);\r\n        }\r\n        this.setState({grid: grid});\r\n    }\r\n\r\n    /**\r\n     * Creates a new node with stored properties.\r\n     * \r\n     * @param {int} row row on grid\r\n     * @param {int} col column on grid\r\n     * @param {int} cost weight cost of node\r\n     * @param {boolean} isWall is node a wall\r\n     * \r\n     * @returns the new node object\r\n     */\r\n    createNode (row, col, cost, isWall) {\r\n        let curVisual = nodeTypes.NODE;\r\n        if (cost !== 1) curVisual = nodeTypes.WEIGHT;\r\n        if (isWall) curVisual = nodeTypes.WALL;\r\n\r\n        return {\r\n            curVisual: curVisual,\r\n            row: row,\r\n            col: col,\r\n            cost: cost,\r\n            distance: Infinity,\r\n            rootDistance: Infinity,\r\n            isStart: row === this.state.startNode[0] && col === this.state.startNode[1],\r\n            isTarget: row === this.state.targetNode[0] && col === this.state.targetNode[1],\r\n            isWall: isWall,\r\n            previousNode: null,\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Updates the state of the grid of nodes. Changes the properties of\r\n     * newly drawn node types according to their current visual state.\r\n     */\r\n    updateGridState () {\r\n        const grid = this.state.grid;\r\n\r\n        for (let r = 0; r < grid.length; r++) {\r\n            for (let c = 0; c < grid[0].length; c++) {\r\n                const node = grid[r][c];\r\n                const type = this.getNodeVisual(node);\r\n\r\n                node.curVisual = nodeTypes.NODE;\r\n                node.isStart = false;\r\n                node.isTarget = false;\r\n                node.isWall = false;\r\n                node.cost = 1;\r\n                \r\n                switch (type) {\r\n                    case nodeTypes.START: \r\n                    case nodeTypes.START_INSTANT:\r\n                        node.curVisual = nodeTypes.START_INSTANT;\r\n                        node.isStart = true;\r\n                        this.setState({startNode: [node.row, node.col]});\r\n                        break;\r\n                    case nodeTypes.TARGET: \r\n                    case nodeTypes.TARGET_INSTANT:\r\n                        node.curVisual = nodeTypes.TARGET_INSTANT;\r\n                        node.isTarget = true;\r\n                        this.setState({targetNode: [node.row, node.col]});\r\n                        break;\r\n                    case nodeTypes.WALL: \r\n                    case nodeTypes.WALL_INSTANT:\r\n                        node.curVisual = nodeTypes.WALL_INSTANT;\r\n                        node.isWall = true;\r\n                        break;\r\n                    case nodeTypes.WEIGHT:\r\n                    case nodeTypes.WEIGHT_INSTANT:\r\n                    case nodeTypes.VISITED_WEIGHT:\r\n                    case nodeTypes.VISITED_WEIGHT_INSTANT:\r\n                    case nodeTypes.PATH_WEIGHT:\r\n                    case nodeTypes.PATH_WEIGHT_INSTANT:\r\n                        node.curVisual = nodeTypes.WEIGHT_INSTANT;\r\n                        node.cost = this.state.weightCost;\r\n                        break;\r\n                    case nodeTypes.VISITED:\r\n                    case nodeTypes.VISITED_INSTANT:\r\n                        node.curVisual = nodeTypes.VISITED_INSTANT;\r\n                        break;\r\n                    case nodeTypes.PATH:\r\n                    case nodeTypes.PATH_INSTANT:\r\n                        node.curVisual = nodeTypes.PATH_INSTANT;\r\n                        break;\r\n                    default:\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n\r\n        this.setState({grid: grid});\r\n    }\r\n\r\n    /**\r\n     * Updates the visual state of a given node.\r\n     * \r\n     * @param {Object} node node on grid\r\n     * @param {nodeTypes} type new node type\r\n     */\r\n    updateNodeVisual (node, type) { document.getElementById(`node-${node.row}-${node.col}`).className = type; }\r\n\r\n    /**\r\n     * Gets the current node type.\r\n     * \r\n     * @param {Object} node \r\n     * \r\n     * @returns current node element class name\r\n     */\r\n    getNodeVisual (node) { return document.getElementById(`node-${node.row}-${node.col}`).className; }\r\n\r\n    /**\r\n     * Sets new start node position. Updates state, we are no\r\n     * longer placing the start node.\r\n     * \r\n     * @param {Object} node node on grid\r\n     */\r\n    drawStartNode (node) { \r\n        const curStart = this.state.grid[this.state.startNode[0]][this.state.startNode[1]];\r\n\r\n        if (node.isStart || node.isTarget) return;\r\n\r\n        this.updateNodeVisual(curStart, nodeTypes.NODE_ANIMATED);\r\n        this.updateNodeVisual(node, nodeTypes.START);\r\n    }\r\n\r\n    /**\r\n     * Sets new target node position. Updates state, we are no\r\n     * longer placing the target node.\r\n     * \r\n     * @param {Object} node node on grid\r\n     */\r\n    drawTargetNode (node) { \r\n        const curTarget = this.state.grid[this.state.targetNode[0]][this.state.targetNode[1]];\r\n\r\n        if (node.isStart || node.isTarget) return;\r\n\r\n        this.updateNodeVisual(curTarget, nodeTypes.NODE_ANIMATED);\r\n        this.updateNodeVisual(node, nodeTypes.TARGET);\r\n    }\r\n\r\n    /**\r\n     * Updates the visual wall state of a given node. \r\n     * \r\n     * @param {Object} node node on grid\r\n     * @param {boolean} isWall are we drawing (true) or erasing (false)\r\n     */\r\n    drawWallNode (node, isWall) {\r\n        if (node.cost !== 1 || node.isStart || node.isTarget) return;\r\n\r\n        if (!isWall) {\r\n            if (this.getNodeVisual(node) === nodeTypes.NODE) return; \r\n            this.updateNodeVisual(node, nodeTypes.NODE_ANIMATED)\r\n        } else if (this.getNodeVisual(node) !== nodeTypes.WALL_INSTANT) {\r\n            this.updateNodeVisual(node, nodeTypes.WALL);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Updates the visual weight state of a given node.\r\n     * \r\n     * @param {Object} node node on grid\r\n     * @param {boolean} isWeight are we drawing (true) or erasing (false)\r\n     */\r\n    drawWeightNode (node, isWeight) {\r\n        if (node.isWall || node.isStart || node.isTarget) return;\r\n\r\n        if (!isWeight) {\r\n            if (this.getNodeVisual(node) === nodeTypes.NODE) return; \r\n            this.updateNodeVisual(node, nodeTypes.NODE_ANIMATED);\r\n        } else if (this.getNodeVisual(node) !== nodeTypes.WEIGHT_INSTANT) {\r\n            this.updateNodeVisual(node, nodeTypes.WEIGHT);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Updates the visual visited state of a given node.\r\n     * \r\n     * @param {Object} node node on grid\r\n     * @param {boolean} isInstant true if drawing instantly\r\n     */\r\n    drawVisitedNode (node, isInstant) {\r\n        if (node.isWall || node.isStart || node.isTarget) return;\r\n\r\n        const isWeight = node.cost !== 1;\r\n\r\n        if (isInstant) {\r\n            if (isWeight) this.updateNodeVisual(node, nodeTypes.VISITED_WEIGHT_INSTANT);\r\n            else this.updateNodeVisual(node, nodeTypes.VISITED_INSTANT);\r\n        } else {\r\n            if (isWeight) this.updateNodeVisual(node, nodeTypes.VISITED_WEIGHT);\r\n            else this.updateNodeVisual(node, nodeTypes.VISITED);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Updates the visual path state of a given node.\r\n     * \r\n     * @param {Object} node node on grid\r\n     * @param {boolean} isInstant true if drawing instantly\r\n     */\r\n    drawPathNode (node, isInstant) {\r\n        if (node.isWall || node.isStart || node.isTarget) return;\r\n\r\n        const isWeight = node.cost !== 1;\r\n\r\n        if (isInstant) {\r\n            if (isWeight) this.updateNodeVisual(node, nodeTypes.PATH_WEIGHT_INSTANT);\r\n            else this.updateNodeVisual(node, nodeTypes.PATH_INSTANT);\r\n        } else {\r\n            if (isWeight) this.updateNodeVisual(node, nodeTypes.PATH_WEIGHT);\r\n            else this.updateNodeVisual(node, nodeTypes.PATH);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clears the entire grid.\r\n     */\r\n    clearGrid () {\r\n        this.clearWeights();\r\n        this.clearWalls();\r\n        this.clearPaths();\r\n    }\r\n\r\n    /**\r\n     * Clears the grid of all wall nodes.\r\n     */\r\n    clearWalls () { \r\n        if (!this.state.interactable) return;\r\n\r\n        const grid = this.state.grid;\r\n        for (const row of grid) {\r\n            for (const node of row) {\r\n                if (node.isWall) {\r\n                    this.updateNodeVisual(node, nodeTypes.NODE);\r\n                    node.isWall = false;\r\n                }\r\n            }\r\n        }\r\n        this.setState({grid: grid});\r\n        this.updateGridState();\r\n    }\r\n\r\n    /**\r\n     * Clears the grid of all weighted nodes and resets their\r\n     * costs to 1.\r\n     */\r\n    clearWeights () {\r\n        if (!this.state.interactable) return;\r\n\r\n        const grid = this.state.grid;\r\n        for (const row of grid) {\r\n            for (const node of row) {\r\n                if (node.cost !== 1) {\r\n                    this.updateNodeVisual(node, nodeTypes.NODE);\r\n                    node.cost = 1;\r\n                }\r\n            }\r\n        }\r\n        this.setState({grid: grid});\r\n        this.updateGridState();\r\n    }\r\n\r\n    /**\r\n     * Clears the visual grid of all path and visited type nodes.\r\n     * Updates the class name of each appropriate node object.\r\n     */\r\n    clearPaths () {\r\n        if (!this.state.interactable) return;\r\n\r\n        for (let r = 0; r < ROW_COUNT; r++) {\r\n            for (let c = 0; c < COL_COUNT; c++) {\r\n                const node = this.state.grid[r][c];\r\n                const type = this.getNodeVisual(node);\r\n\r\n                if (type === nodeTypes.VISITED || \r\n                    type === nodeTypes.VISITED_INSTANT ||\r\n                    type === nodeTypes.PATH || \r\n                    type === nodeTypes.PATH_INSTANT) {\r\n\r\n                    this.updateNodeVisual(node, nodeTypes.NODE);\r\n                }\r\n                else if (type === nodeTypes.VISITED_WEIGHT || \r\n                    type === nodeTypes.VISITED_WEIGHT_INSTANT || \r\n                    type === nodeTypes.PATH_WEIGHT ||\r\n                    type === nodeTypes.PATH_WEIGHT_INSTANT) {\r\n                \r\n                    this.updateNodeVisual(node, nodeTypes.WEIGHT_INSTANT);\r\n                }\r\n            }\r\n        }\r\n        this.updateAlgorithmInfo(\"None\", 0, 0, 0);\r\n        this.updateGridState();\r\n    }\r\n\r\n    /**\r\n     * Resets the start and target nodes to their initial locations.\r\n     */\r\n    resetStartTarget () {\r\n        if (!this.state.interactable) return;\r\n\r\n        this.clearPaths();\r\n\r\n        const initStart = this.state.grid[INIT_START[0]][INIT_START[1]];\r\n        const initTarget = this.state.grid[INIT_TARGET[0]][INIT_TARGET[1]];\r\n\r\n        this.drawStartNode(initStart);\r\n        this.drawTargetNode(initTarget);\r\n        this.updateGridState();\r\n    }\r\n\r\n    /**\r\n     * Sets new cost of weighted nodes.\r\n     * \r\n     * @param {int} weight new cost\r\n     */\r\n    setNewWeight (weight) { this.setState({weightCost: weight}); }\r\n\r\n    /**\r\n     * Sets the current draw mode.\r\n     * \r\n     * 0: none\r\n     * 1: walls\r\n     * 2: weights\r\n     * 3: start\r\n     * 4: target\r\n     * \r\n     * @param {int} mode new draw mode\r\n     */\r\n    setDrawMode (mode) { \r\n        if (this.state.drawMode === mode) mode = 0;\r\n        this.setState({drawMode: mode}); \r\n    }\r\n\r\n    /**\r\n     * Visualizes a given pathfinding algorithm. Uses the current state of\r\n     * the grid of nodes.\r\n     * \r\n     * @param {pathfindAlgorithms} algorithm pathfinding algorithm\r\n     * @param {int} speed time in miliseconds between visit animations\r\n     */\r\n    visualizePathfind (algorithm, speed) {\r\n        if (!this.state.interactable) return;\r\n\r\n        this.clearPaths();\r\n        this.softRebuildGrid();\r\n\r\n        const grid = this.state.grid;\r\n        const start = grid[this.state.startNode[0]][this.state.startNode[1]];\r\n        const target = grid[this.state.targetNode[0]][this.state.targetNode[1]];\r\n\r\n        var visitedNodes = [];\r\n        switch (algorithm) {\r\n            case pathfindAlgorithms.DIJKSTRA:\r\n                visitedNodes = dijkstra(grid, start, target);\r\n                break;\r\n            case pathfindAlgorithms.ASTAR:\r\n                visitedNodes = aStar(grid, start, target);\r\n                break;\r\n            case pathfindAlgorithms.BFS:\r\n                visitedNodes = breadthFirstSearch(grid, start, target);\r\n                break;\r\n            case pathfindAlgorithms.DFS:\r\n                visitedNodes = depthFirstSearch(grid, start, target);\r\n                break;\r\n            default:\r\n                return;\r\n        }\r\n\r\n        const shortestPath = getShortestPathNodes(target);\r\n        const totalCost = getShortestPathCost(target);\r\n\r\n        this.updateAlgorithmInfo(algorithm, visitedNodes.length, shortestPath.length, totalCost);\r\n\r\n        this.animateSearch(visitedNodes, shortestPath, speed);\r\n    }\r\n\r\n    /**\r\n     * Animates the process of the pathfinding algorithm. Updates the class\r\n     * names of the nodes to change their appearance.\r\n     * \r\n     * @param {Array} visitedNodes array of visited nodes in order\r\n     * @param {Array} shortestPath array of shortest path nodes in order\r\n     * @param {int} speed time in miliseconds between visit animations\r\n     */\r\n    animateSearch (visitedNodes, shortestPath, speed) {\r\n        const isInstant = speed === 0;\r\n        if (!speed) speed = VISITED_SPEED;\r\n\r\n        if (isInstant) {\r\n            for (let i = 0; i < visitedNodes.length; i++) {\r\n                const node = visitedNodes[i];\r\n                this.drawVisitedNode(node, isInstant);\r\n            }\r\n            this.animatePath(shortestPath, isInstant);\r\n        } else {\r\n            this.setState({interactable: false});\r\n\r\n            for (let i = 0; i < visitedNodes.length; i++) {\r\n                setTimeout(() => {\r\n                    const node = visitedNodes[i];\r\n                    this.drawVisitedNode(node, isInstant);\r\n                }, speed * i);\r\n            }\r\n            setTimeout(() => { this.animatePath(shortestPath, isInstant); }, speed * visitedNodes.length);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Animates the shortest path from the start node to the target node.\r\n     * Updates the class names of the nodes to change their appearance.\r\n     * \r\n     * @param {Array} shortestPath array of shortest path nodes in order \r\n     * @param {boolean} isInstant true if drawing instantly\r\n     */\r\n    animatePath (shortestPath, isInstant) {\r\n        if (isInstant) {\r\n            for (let i = 1; i < shortestPath.length; i++) {\r\n                const node = shortestPath[i];\r\n                this.drawPathNode(node, isInstant);\r\n            }\r\n            setTimeout(() => { this.updateGridState() }, 0);\r\n        } else {\r\n            for (let i = 0; i < shortestPath.length; i++) {\r\n                setTimeout(() => {\r\n                    const node = shortestPath[i];\r\n                    this.drawPathNode(node, isInstant)\r\n                }, PATH_SPEED * i);\r\n            }\r\n            setTimeout(() => { \r\n                this.updateGridState();\r\n                this.setState({interactable: true});\r\n            }, PATH_SPEED * shortestPath.length);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Updates the visual algorithm information.\r\n     * \r\n     * @param {string} algorithm current algorithm\r\n     * @param {int} visitedNodes amount of nodes visited\r\n     * @param {int} pathNodes amount of nodes in path\r\n     * @param {int} totalCost total cost of shortest path\r\n     */\r\n    updateAlgorithmInfo (algorithm, visitedNodes, pathNodes, totalCost) {\r\n        if (pathNodes <= 1) pathNodes = \"No Path\";\r\n        if (totalCost <= 1) totalCost = 0;\r\n\r\n        document.getElementById(\"visited-info-text\").innerHTML = `${visitedNodes}`;\r\n        document.getElementById(\"path-info-text\").innerHTML = `${pathNodes}`;\r\n        document.getElementById(\"weighted-info-text\").innerHTML = `${totalCost}`;\r\n    }\r\n\r\n    /**\r\n     * Animates a generated maze.\r\n     * \r\n     * @param {mazeAlgorithms} algorithm maze algorithm to use\r\n     */\r\n    animateMaze (algorithm) {\r\n        var maze = [];\r\n\r\n        switch (algorithm) {\r\n            case mazeAlgorithms.RECURSIVE_DEVISION:\r\n                maze = recursiveDevision(ROW_COUNT, COL_COUNT);\r\n                break;\r\n            case mazeAlgorithms.RANDOM_WALL:\r\n                maze = randomWallMaze(ROW_COUNT, COL_COUNT);\r\n                break;\r\n            case mazeAlgorithms.RANDOM_WEIGHT:\r\n                maze = randomWeightMaze(ROW_COUNT, COL_COUNT);\r\n                break;\r\n            case mazeAlgorithms.RANDOM_WALL_WEIGHT:\r\n                maze = randomWallWeightMaze(ROW_COUNT, COL_COUNT);\r\n                break;\r\n            default:\r\n                return;\r\n        }\r\n\r\n        if (!this.state.interactable) return;\r\n        this.setState({interactable: false});\r\n        this.clearGrid();\r\n\r\n        for (let i = 0; i < maze.length; i++) {\r\n            setTimeout(() => {\r\n                const node = this.state.grid[maze[i][0]][maze[i][1]];\r\n                if (maze[i][2]) this.drawWeightNode(node, true);\r\n                else this.drawWallNode(node, true);\r\n            }, MAZE_SPEED * i);\r\n        }\r\n        setTimeout(() => {\r\n            this.updateGridState();\r\n            this.setState({interactable: true});\r\n        }, MAZE_SPEED * maze.length);\r\n    }\r\n\r\n    /**\r\n     * Runs on page load. Rebuilds the grid.\r\n     */\r\n    componentDidMount () { this.rebuildGrid(); }\r\n\r\n    /**\r\n     * Handles a mouse down event on a node. If we are placing the start or\r\n     * target node, update the node location and return. Otherwise, updates\r\n     * the node based on the current draw mode.\r\n     * \r\n     * @param {int} row row of node on grid\r\n     * @param {int} col column of node on grid\r\n     */\r\n    handleMouseDown (row, col) {\r\n        if (!this.state.interactable) return;\r\n        this.setState({mouseIsDown: true});\r\n\r\n        const grid = this.state.grid;\r\n        const node = grid[row][col];\r\n        if (node.isStart || node.isTarget) return;\r\n\r\n        switch (this.state.drawMode) {\r\n            case 1: // Wall\r\n                const isWall = node.isWall;\r\n                this.drawWallNode(node, !isWall);\r\n                this.setState({drawWall: !isWall});\r\n                break;\r\n            case 2: // Weight\r\n                const isWeight = node.cost !== 1;\r\n                this.drawWeightNode(node, !isWeight);\r\n                this.setState({drawWeight: !isWeight});\r\n                break;\r\n            case 3: // Start\r\n                this.clearPaths();\r\n                this.drawStartNode(node);\r\n                this.setState({drawMode: 0});\r\n                break;\r\n            case 4: // Target\r\n                this.clearPaths();\r\n                this.drawTargetNode(node);\r\n                this.setState({drawMode: 0});\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handles a mouse up event. Sets the state so that nothing\r\n     * can be drawn.\r\n     */\r\n    handleMouseUp () {\r\n        if (!this.state.mouseIsDown) return;\r\n\r\n        this.updateGridState();\r\n\r\n        this.setState({\r\n            mouseIsDown: false,\r\n            drawWall: null,\r\n            drawWeight: null,\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Handles a mouse enter event into a node. If the mouse is not down,\r\n     * return. Otherwise, updates the node based on the current draw mode.\r\n     * \r\n     * @param {int} row row of node on grid\r\n     * @param {int} col column of node on grid\r\n     */\r\n    handleMouseEnter (row, col) {\r\n        if (!this.state.interactable) return;\r\n\r\n        const grid = this.state.grid;\r\n        const node = grid[row][col];\r\n\r\n        const isWall = node.isWall;\r\n        const isWeight = node.cost !== 1;\r\n\r\n        const isPreview = !isWall && !isWeight && !node.isStart && !node.isTarget;\r\n\r\n        switch (this.state.drawMode) {\r\n            case 1:\r\n                if (this.state.mouseIsDown && isWall !== this.state.drawWall) {\r\n                    this.drawWallNode(node, !isWall);\r\n                } else if (!this.state.mouseIsDown && isPreview) this.updateNodeVisual(node, nodeTypes.WALL_PREVIEW);\r\n                break;\r\n            case 2:\r\n                if (this.state.mouseIsDown && isWeight !== this.state.drawWeight) {\r\n                    this.drawWeightNode(node, !isWeight);\r\n                } else if (!this.state.mouseIsDown && isPreview) this.updateNodeVisual(node, nodeTypes.WEIGHT_PREVIEW);\r\n                break; \r\n            case 3:\r\n                if (isPreview) this.updateNodeVisual(node, nodeTypes.START_PREVIEW);\r\n                break;\r\n            case 4:\r\n                if (isPreview) this.updateNodeVisual(node, nodeTypes.TARGET_PREVIEW);\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handles a mouse leave event from a node.\r\n     * \r\n     * @param {int} row row of node on grid\r\n     * @param {int} col column of node on grid\r\n     */\r\n    handleMouseLeft (row, col) {\r\n        if (this.state.mouseIsDown || this.state.drawMode === 0 || !this.state.interactable) return;\r\n        \r\n        const node = this.state.grid[row][col];\r\n\r\n        if (node.isWall || node.cost !== 1 || node.isStart || node.isTarget) return;\r\n\r\n        this.updateNodeVisual(node, node.curVisual);\r\n    }\r\n\r\n    /**\r\n     * Handles an animation end event of a node. Updates the class name of the\r\n     * node to the instant class version.\r\n     * \r\n     * @param {Object} node node on grid\r\n     */\r\n    handleAnimationEnd (node) {\r\n        const type = this.getNodeVisual(node);\r\n        switch (type) {\r\n            case nodeTypes.START:\r\n                this.updateNodeVisual(node, nodeTypes.START_INSTANT);\r\n                break;\r\n            case nodeTypes.TARGET:\r\n                this.updateNodeVisual(node, nodeTypes.TARGET_INSTANT);\r\n                break;\r\n            case nodeTypes.WALL:\r\n                this.updateNodeVisual(node, nodeTypes.WALL_INSTANT);\r\n                break;\r\n            case nodeTypes.WEIGHT:\r\n                this.updateNodeVisual(node, nodeTypes.WEIGHT_INSTANT);\r\n                break;\r\n            case nodeTypes.VISITED:\r\n                this.updateNodeVisual(node, nodeTypes.VISITED_INSTANT);\r\n                break;\r\n            case nodeTypes.VISITED_WEIGHT:\r\n                this.updateNodeVisual(node, nodeTypes.VISITED_WEIGHT_INSTANT);\r\n                break;\r\n            case nodeTypes.PATH:\r\n                this.updateNodeVisual(node, nodeTypes.PATH_INSTANT);\r\n                break;\r\n            case nodeTypes.PATH_WEIGHT:\r\n                this.updateNodeVisual(node, nodeTypes.PATH_WEIGHT_INSTANT);\r\n                break;\r\n            default:\r\n                this.updateNodeVisual(node, nodeTypes.NODE);\r\n                break;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Renders the pathfinding visualizer component.\r\n     * \r\n     * @returns a <div> element representing the component\r\n     */\r\n    render () {\r\n        //console.log(this.state.grid);\r\n\r\n        return (\r\n            <div className=\"pathfind-vis\">\r\n                <div className=\"pathfind-menu\">\r\n                    <PathfindMenu pathfinder={this} />\r\n                </div>\r\n                <div \r\n                className=\"grid\" \r\n                onMouseUp={() => this.handleMouseUp()}\r\n                onMouseLeave={() => this.handleMouseUp()}\r\n                onContextMenu={(e) => e.preventDefault()}\r\n                onDragStart={(e) => e.preventDefault()}\r\n                >\r\n                    {Array.from(this.state.grid).map((row, rowIdx) => {\r\n                        return (\r\n                            <div key={rowIdx} className=\"grid-row\">\r\n                                {Array.from(row).map((node, nodeIdx) => {\r\n                                    const {row, col, isStart, isTarget} = node;\r\n                                    return (\r\n                                        <Node key={nodeIdx}\r\n                                        row={row}\r\n                                        col={col}\r\n                                        isStart={isStart}\r\n                                        isTarget={isTarget}\r\n                                        mousePressed={(row, col) => this.handleMouseDown(row, col)}\r\n                                        mouseEntered={(row, col) => this.handleMouseEnter(row, col)}\r\n                                        mouseLeft={(row, col) => this.handleMouseLeft(row, col)}\r\n                                        animationEnded={() => this.handleAnimationEnd(node)}\r\n                                        />\r\n                                    );\r\n                                })}\r\n                            </div>\r\n                        );\r\n                    })}\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default PathfindingVisualizer;","// Unsorted bar color\r\nconst UNSORTED = \"pink\";\r\n// Comparing bar color\r\nconst COMPARE = \"red\";\r\n// Sorted bar color\r\nconst SORTED = \"green\";\r\n// Swapping bar color\r\nconst SWAP = \"orange\";\r\n// Minimum bar color\r\nconst MIN = \"purple\";\r\n\r\n// Sorting algorithms\r\nexport const sortAlgorithms = {\r\n    SELECTION: \"selection\",\r\n    INSERTION: \"insertion\",\r\n    MERGE: \"merge\",\r\n}\r\n\r\n/**\r\n * Executes a Selection Sort on an array.\r\n * \r\n * @param {Array} array array of values\r\n * \r\n * @returns an array of animations\r\n */\r\nexport function selectionSort(array) {\r\n    const animations = [];\r\n\r\n    for (let i = 0; i < array.length; i++) {\r\n        var min = i;\r\n        animations.push([[MIN, min]]);\r\n        var newMin = true;\r\n        for (let k = i + 1; k < array.length; k++) {\r\n            if (newMin) {\r\n                animations.push([[COMPARE, k]]);\r\n                newMin = false;\r\n            } else animations.push([[UNSORTED, k-1], [COMPARE, k]]);\r\n            \r\n            if (array[min] > array[k]) {\r\n                animations.push([[UNSORTED, min], [MIN, k]]);\r\n                min = k;\r\n                newMin = true;\r\n            }\r\n        }\r\n        if (min !== i) {\r\n            animations.push([[UNSORTED, array.length-1], [SWAP, min, i], [null, min, array[i]], [null, i, array[min]]]);\r\n            animations.push([[UNSORTED, min], [SORTED, i]]);\r\n            var temp = array[i];\r\n            array[i] = array[min];\r\n            array[min] = temp;\r\n        } else animations.push([[UNSORTED, array.length-1], [SORTED, i]]);\r\n    }\r\n\r\n    return animations;\r\n}\r\n\r\n/**\r\n * Executes a Insertion Sort on an array.\r\n * \r\n * @param {Array} array array of values\r\n * \r\n * @returns an array of animations\r\n */\r\nexport function insertionSort(array) {\r\n    const animations = [];\r\n\r\n    for (let i = 1; i < array.length; i++) {\r\n        var cur = array[i];\r\n        var j = i - 1;\r\n        \r\n        animations.push([[COMPARE, j, i]]);\r\n        while (j >= 0) {\r\n            if (j + 2 >= array.length) animations.push([[COMPARE, j, j + 1]]);\r\n            else animations.push([[UNSORTED, j + 2], [COMPARE, j, j + 1]]);\r\n            if (array[j] <= cur) {\r\n                animations.push([[UNSORTED, j, j + 1]]);\r\n                break;\r\n            }\r\n            animations.push([[SWAP, j, j + 1], [null, j + 1, array[j]], [null, j, cur]]);\r\n            array[j + 1] = array[j];\r\n            j--;\r\n        }\r\n        if (j + 2 >= array.length) animations.push([[UNSORTED, j + 1]]);\r\n        else animations.push([[UNSORTED, j + 1, j + 2]]);\r\n        animations.push([[null, j + 1, cur]]);\r\n        array[j+1] = cur;\r\n    }\r\n    for (let i = array.length - 1; i >= 0; i--) animations.push([[SORTED, i]]);\r\n\r\n    return animations;\r\n}\r\n\r\n/**\r\n * Executes a Merge Sort on an array.\r\n * \r\n * @param {Array} array array of values\r\n * \r\n * @returns an array of animations\r\n */\r\nexport function mergeSort(array) {\r\n    const animations = [];\r\n    array = doMergeSort(animations, array);\r\n    return animations;\r\n}\r\n\r\n/**\r\n * Actual recursive Merge Sort function.\r\n * \r\n * @param {Array} animations array of animations\r\n * @param {Array} array array of values \r\n * \r\n * @returns sorted array\r\n */\r\nfunction doMergeSort(animations, array) {\r\n    const middle = array.length / 2;\r\n    if (array.length < 2) return array;\r\n    const left = array.splice(0, middle);\r\n    return merge(animations, doMergeSort(animations, left), doMergeSort(animations, array));\r\n}\r\n\r\n/**\r\n * Merge Sort helper function.\r\n * \r\n * @param {Array} animations array of animations\r\n * @param {Array} left left array\r\n * @param {Array} right right array\r\n * \r\n * @returns merged array\r\n */\r\nfunction merge (animations, left, right) {\r\n    var array = [];\r\n\r\n    while (left.length && right.length) {\r\n        if (left[0] < right[0]) array.push(left.shift());\r\n        else array.push(right.shift());\r\n    }\r\n    return [...array, ...left, ...right];\r\n}","import React from 'react';\r\nimport { Container, Row, Col, Button, ButtonDropdown, DropdownItem, DropdownToggle, DropdownMenu\r\n} from 'reactstrap';\r\n\r\nimport { sortAlgorithms } from './SortAlgorithms';\r\n\r\n/**\r\n * Represents the top menu of the sorting visualizer component.\r\n * \r\n * @author Jake Waclawski\r\n */\r\nclass SortMenu extends React.Component {\r\n    constructor (props) {\r\n        super(props);\r\n        // Visualize button dropdown status\r\n        this.state = { visualizeDropdownOpen: false };\r\n    }\r\n\r\n    /**\r\n     * Toggles the visualize button dropdown.\r\n     */\r\n    toggleVisualize () { this.setState({visualizeDropdownOpen: !this.state.visualizeDropdownOpen}); }\r\n \r\n    /**\r\n     * Renders the menu component.\r\n     * \r\n     * @returns a <div> element representing the menu\r\n     */\r\n    render () {\r\n        return (\r\n            <div className=\"sort-menu\">\r\n                <Container>\r\n                    <Row>\r\n                        <Col className=\"title\">\r\n                            Sorting Visualizer\r\n                        </Col>\r\n                        <Col>\r\n                            <Container>\r\n                                <Row>\r\n                                    <Col>\r\n                                        <ButtonDropdown isOpen={this.state.visualizeDropdownOpen} toggle={() => this.toggleVisualize()}>\r\n                                            <Button color=\"success\" onClick={() => this.toggleVisualize()}>Visualize</Button>\r\n                                            <DropdownToggle split color=\"success\" />\r\n                                            <DropdownMenu>\r\n                                                <DropdownItem onClick={() => this.props.sorter.visualizeSort(sortAlgorithms.SELECTION)}>Selection Sort</DropdownItem>\r\n                                                <DropdownItem onClick={() => this.props.sorter.visualizeSort(sortAlgorithms.INSERTION)}>Insertion Sort</DropdownItem>\r\n                                                <DropdownItem onClick={() => this.props.sorter.visualizeSort(sortAlgorithms.MERGE)}>Merge Sort</DropdownItem>\r\n                                            </DropdownMenu>\r\n                                        </ButtonDropdown>\r\n                                    </Col>\r\n                                    <Col>\r\n                                        <Button color=\"warning\" onClick={() => this.props.sorter.reGenerateArray()}>Randomize</Button>\r\n                                    </Col>\r\n                                </Row>\r\n                            </Container>\r\n                        </Col>\r\n                    </Row>\r\n                </Container>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default SortMenu;","import React from 'react';\r\n\r\nimport './SortingVisualizer.css';\r\n\r\nimport { random } from '../utils';\r\nimport SortMenu from './SortMenu';\r\nimport { selectionSort, insertionSort, mergeSort, sortAlgorithms } from './SortAlgorithms';\r\n\r\n// Size of array\r\nconst ARRAY_SIZE = 100;\r\n// Minimum value in array\r\nconst MIN_VALUE = 5;\r\n// Maximum value in array\r\nconst MAX_VALUE = 500;\r\n// Speed between animations in miliseconds\r\nconst SPEED = 10;\r\n\r\n// Unsorted bar color\r\nconst UNSORTED = \"pink\";\r\n\r\n/**\r\n * Represents the sorting visualizer component.\r\n * \r\n * @author Jake Waclawski\r\n */\r\nclass SortingVisualizer extends React.Component {\r\n    constructor (props) {\r\n        super(props);\r\n        // Array of bar values\r\n        this.state = { array: [] };\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the array with new random values.\r\n     * \r\n     * @param {int} size size of array\r\n     * @param {int} min minimum value\r\n     * @param {int} max maximum value\r\n     */\r\n    rebuildArray (size, min, max) {\r\n        const array = [];\r\n        for (let i = 0; i < size; i++) { array.push(this.createBar(min, max)); }\r\n        return array;\r\n    }\r\n\r\n    /**\r\n     * Creates a new bar with a random value.\r\n     * \r\n     * @param {int} min lower bound of value\r\n     * @param {int} max upper bound of value\r\n     * \r\n     * @returns the created bar\r\n     */\r\n    createBar (min, max) { return random(min, max); }\r\n\r\n    /**\r\n     * Rebuilds the array and regenerates the visual array bars.\r\n     */\r\n    reGenerateArray () { \r\n        var array = this.state.array;\r\n        array = this.rebuildArray(ARRAY_SIZE, MIN_VALUE, MAX_VALUE);\r\n        const bars = document.getElementsByClassName(\"bar\");\r\n        for (let i = 0; i < array.length; i++) { bars[i].style.backgroundColor = UNSORTED; }\r\n        this.setState({array: array}); \r\n    }\r\n\r\n    /**\r\n     * Visualizes a given sorting algorithm.\r\n     * \r\n     * @param {sortAlgorithms} algorithm sorting algorithm\r\n     */\r\n    visualizeSort (algorithm) {\r\n        const array = this.state.array;\r\n        var animations = [];\r\n\r\n        switch (algorithm) {\r\n            case sortAlgorithms.SELECTION:\r\n                animations = selectionSort(array);\r\n                break;\r\n            case sortAlgorithms.INSERTION:\r\n                animations = insertionSort(array);\r\n                break;\r\n            case sortAlgorithms.MERGE:\r\n                animations = mergeSort(array);\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n\r\n        this.animateSort(animations);\r\n    }\r\n\r\n    /**\r\n     * Animates the process of the sorting algorithm. Iterates through an\r\n     * array of animation steps generated by the algorithm.\r\n     * \r\n     * @param {Array} animations \r\n     */\r\n    animateSort (animations) {\r\n        const bars = document.getElementsByClassName(\"bar\");\r\n        var i = 0\r\n        for (const step of animations) {\r\n            setTimeout(() => {\r\n                for (const action of step) { \r\n                    if (action[0] === null) {\r\n                        bars[action[1]].style.height = `${action[2]}px`;\r\n                    } else {\r\n                        for (let k = 1; k < action.length; k++) {\r\n                            bars[action[k]].style.backgroundColor = action[0]; \r\n                        }\r\n                    }\r\n                }\r\n            }, SPEED * i++);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Runs on page load. Rebuilds the array.\r\n     */\r\n    componentDidMount () {\r\n        const array = this.rebuildArray(ARRAY_SIZE, MIN_VALUE, MAX_VALUE);\r\n        this.setState({array: array});\r\n    }\r\n\r\n    /**\r\n     * Renders the sorting visualizer component.\r\n     * \r\n     * @returns a <div> element representing the component\r\n     */\r\n    render () {\r\n        //console.log(this.state.array);\r\n\r\n        return (\r\n            <div className=\"sort-vis\">\r\n                <div className=\"sort-menu\">\r\n                    <SortMenu sorter={this}/>\r\n                </div>\r\n                <div className=\"array\">\r\n                    {Array.from(this.state.array).map((bar, barIdx) => {\r\n                        return (\r\n                            <div className=\"bar\"\r\n                            key={barIdx}\r\n                            style={{\r\n                                backgroundColor: UNSORTED,\r\n                                height: `${bar}px`,\r\n                            }}/>\r\n                        );\r\n                    })}\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default SortingVisualizer;","import React from 'react';\r\nimport { NavItem, NavLink, Nav, TabContent, TabPane\r\n} from 'reactstrap'\r\nimport classnames from 'classnames';\r\n\r\nimport Home from './Home';\r\nimport PathfindingVisualizer from './PathfindingVisualizer/PathfindingVisualizer';\r\nimport SortingVisualizer from './SortingVisualizer/SortingVisualizer';\r\n\r\n// Default tab to display on page load\r\nconst DEFAULT_TAB = \"home\";\r\n\r\n/**\r\n * Represents the navigation bar at the top of the page. Each tab\r\n * contains one component of the project.\r\n * \r\n * @author Jake Waclawski\r\n */\r\nclass NavBar extends React.Component {\r\n    constructor (props) {\r\n        super(props);\r\n        // Current active tab\r\n        this.state = { activeTab: DEFAULT_TAB };\r\n    }\r\n\r\n    /**\r\n     * Renders the navigation bar.\r\n     * \r\n     * @returns a <div> element representing the navigation bar\r\n     */\r\n    render () {\r\n        return (\r\n            <div className=\"nav-bar\">\r\n                <Nav tabs>\r\n                    <NavItem>\r\n                        <NavLink className={classnames({active: this.state.activeTab === \"home\"})}\r\n                        onClick={() => this.setState({activeTab: \"home\"})}\r\n                        >Home\r\n                        </NavLink>\r\n                    </NavItem>\r\n                    <NavItem>\r\n                        <NavLink className={classnames({active: this.state.activeTab === \"pathfind\"})}\r\n                        onClick={() => this.setState({activeTab: \"pathfind\"})}\r\n                        >Pathfinding Visualizer\r\n                        </NavLink>\r\n                    </NavItem>\r\n                    <NavItem>\r\n                        <NavLink className={classnames({active: this.state.activeTab === \"sort\"})}\r\n                        onClick={() => this.setState({activeTab: \"sort\"})}\r\n                        >Sorting Visualizer\r\n                        </NavLink>\r\n                    </NavItem>\r\n                </Nav>\r\n                <TabContent activeTab={this.state.activeTab}>\r\n                    <TabPane tabId=\"home\">\r\n                        <Home />\r\n                    </TabPane>\r\n                    <TabPane tabId=\"pathfind\">\r\n                        <PathfindingVisualizer />\r\n                    </TabPane>\r\n                    <TabPane tabId=\"sort\">\r\n                        <SortingVisualizer />\r\n                    </TabPane>\r\n                </TabContent>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default NavBar;","import './App.css';\r\nimport NavBar from './NavBar';\r\n\r\nfunction App() {\r\n  return (\r\n    <div className=\"App\">\r\n      <NavBar></NavBar>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","const reportWebVitals = onPerfEntry => {\r\n  if (onPerfEntry && onPerfEntry instanceof Function) {\r\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\r\n      getCLS(onPerfEntry);\r\n      getFID(onPerfEntry);\r\n      getFCP(onPerfEntry);\r\n      getLCP(onPerfEntry);\r\n      getTTFB(onPerfEntry);\r\n    });\r\n  }\r\n};\r\n\r\nexport default reportWebVitals;\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport App from './App';\r\nimport reportWebVitals from './reportWebVitals';\r\n\r\nimport 'bootstrap/dist/css/bootstrap.min.css';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n\r\n// If you want to start measuring performance in your app, pass a function\r\n// to log results (for example: reportWebVitals(console.log))\r\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\r\nreportWebVitals();\r\n"],"sourceRoot":""}