{"version":3,"sources":["Home.js","Utils.js","PathfindingVisualizer/PathfindAlgorithms.js","PathfindingVisualizer/MazeAlgorithms.js","PathfindingVisualizer/PathfindMenu.js","PathfindingVisualizer/Node.js","PathfindingVisualizer/PathfindingVisualizer.js","SortingVisualizer/SortAlgorithms.js","SortingVisualizer/SortMenu.js","SortingVisualizer/SortingVisualizer.js","NavBar.js","App.js","reportWebVitals.js","index.js"],"names":["Home","props","state","Card","CardHeader","href","CardBody","React","Component","QElement","element","priority","this","random","min","max","Math","floor","PriorityQueue","items","i","length","has","contains","splice","enqueue","qElement","contain","push","isEmpty","shift","str","pathfindAlgorithms","dijkstra","grid","start","target","visitedNodes","unvisitedNodes","nodes","row","node","getAllNodes","distance","sort","a","b","curNode","isWall","Infinity","isVisited","unvisitedNeighbors","getUnvisitedNeighbors","neighbor","cost","previousNode","neighbors","col","filter","recursiveDevision","rows","cols","walls","r","c","innerWalls","buildWalls","h","minC","maxC","minR","maxR","hole","addHWall","addVWall","PathfindMenu","visualizeDropdownOpen","editDropdownOpen","mazeDropdownOpen","clearDropdownOpen","isInstant","setState","className","Container","Row","Col","ButtonDropdown","isOpen","toggle","toggleVisualize","Button","color","onClick","getIsInstantText","DropdownToggle","split","DropdownMenu","DropdownItem","toggleInstant","divider","pathfinder","visualizePathfind","toggleEdit","setDrawMode","resetStartTarget","placeStartNode","placeTargetNode","toggleMaze","animateMaze","toggleClear","clearGrid","clearWeights","clearWalls","clearPaths","Node","nodeType","isStart","isTarget","id","onMouseDown","mousePressed","onMouseEnter","mouseEntered","INIT_START","INIT_TARGET","nodeTypes","PathfindingVisualizer","weightCost","mouseIsDown","drawMode","drawWall","drawWeight","placingStart","placingTarget","startNode","targetNode","curRow","createNode","oldGrid","rootDistance","isWeight","nodeElement","document","getElementById","curStart","curStartNew","newNode","curTarget","curTargetNew","softRebuildGrid","setStartNode","setTargetNode","weight","mode","algorithm","updateGrid","dequeue","manhattanD","abs","minDistance","setPriority","aStar","breadthFirstSearch","pop","depthFirstSearch","shortestPath","nodesInShortestPath","currentNode","unshift","getShortestPathNodes","animateSearch","setTimeout","animatePath","maze","drawWallNode","rebuildGrid","drawWeightNode","onMouseUp","handleMouseUp","onMouseLeave","onContextMenu","e","preventDefault","onDragStart","Array","from","map","rowIdx","nodeIdx","handleMouseDown","handleMouseEnter","UNSORTED","COMPARE","SORTED","SWAP","MIN","sortAlgorithms","mergeSort","array","animations","doMergeSort","middle","left","right","merge","SortMenu","sorter","visualizeSort","reGenerateArray","SortingVisualizer","size","createBar","rebuildArray","bars","getElementsByClassName","style","backgroundColor","newMin","k","temp","selectionSort","cur","j","insertionSort","animateSort","step","action","height","bar","barIdx","NavBar","activeTab","Nav","tabs","NavItem","NavLink","classnames","active","TabContent","TabPane","tabId","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.08387920.chunk.js","sourcesContent":["import React from 'react';\r\nimport { Card, CardHeader, CardBody\r\n} from 'reactstrap';\r\n\r\n/**\r\n * Represents the home tab component.\r\n * \r\n * @author Jake Waclawski\r\n */\r\nclass Home extends React.Component {\r\n    constructor (props) {\r\n        super(props);\r\n        this.state = {};\r\n    }\r\n\r\n    /**\r\n     * Renders the home tab component.\r\n     * \r\n     * @returns a <div> element representing the component\r\n     */\r\n    render () {\r\n        return (\r\n            <div>\r\n                <Card>\r\n                    <CardHeader>\r\n                        Jake Waclawski<br></br>\r\n                        <a href=\"https://github.com/jmw3638/Pathfinder\">GitHub</a>\r\n                    </CardHeader>\r\n                    <CardBody>\r\n                    </CardBody>\r\n                </Card>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default Home;","// User defined class \r\n// to store element and its priority \r\nclass QElement { \r\n    constructor(element, priority) \r\n    { \r\n        this.element = element; \r\n        this.priority = priority; \r\n    } \r\n} \r\n\r\nexport function random(min, max) { return Math.floor(Math.random() * (max - min + 1) + min); }\r\n  \r\n// PriorityQueue class \r\nclass PriorityQueue { \r\n  \r\n    // An array is used to implement priority \r\n    constructor() \r\n    { \r\n        this.items = []; \r\n    } \r\n  \r\n    contains(element) {\r\n        for (var i = 0; i < this.items.length; i++) {\r\n            if(this.items[i].element === element) return i;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    setPriority(element, priority) {\r\n        var has = this.contains(element);\r\n        if(!has) return;\r\n        this.items.splice(has, 1);\r\n        this.enqueue(element, priority);\r\n    }\r\n\r\n    // enqueue function to add element \r\n    // to the queue as per priority \r\n    enqueue(element, priority) \r\n    { \r\n        // creating object from queue element \r\n        var qElement = new QElement(element, priority); \r\n        var contain = false; \r\n    \r\n        // iterating through the entire \r\n        // item array to add element at the \r\n        // correct location of the Queue \r\n        for (var i = 0; i < this.items.length; i++) { \r\n            if (this.items[i].priority > qElement.priority) { \r\n                // Once the correct location is found it is \r\n                // enqueued \r\n                this.items.splice(i, 0, qElement); \r\n                contain = true; \r\n                break; \r\n            } \r\n        } \r\n    \r\n        // if the element have the highest priority \r\n        // it is added at the end of the queue \r\n        if (!contain) { \r\n            this.items.push(qElement); \r\n        } \r\n    } \r\n\r\n    // dequeue method to remove \r\n    // element from the queue \r\n    dequeue() \r\n    { \r\n        // return the dequeued element \r\n        // and remove it. \r\n        // if the queue is empty \r\n        // returns Underflow \r\n        if (this.isEmpty()) \r\n            return \"Underflow\"; \r\n        return this.items.shift(); \r\n    } \r\n\r\n\r\n    // front function \r\n    front() \r\n    { \r\n        // returns the highest priority element \r\n        // in the Priority queue without removing it. \r\n        if (this.isEmpty()) \r\n            return \"No elements in Queue\"; \r\n        return this.items[0]; \r\n    } \r\n\r\n    // rear function \r\n    rear() \r\n    { \r\n        // returns the lowest priorty \r\n        // element of the queue \r\n        if (this.isEmpty()) \r\n            return \"No elements in Queue\"; \r\n        return this.items[this.items.length - 1]; \r\n    } \r\n\r\n    // isEmpty function \r\n    isEmpty() \r\n    { \r\n        // return true if the queue is empty. \r\n        return this.items.length === 0; \r\n    } \r\n\r\n\r\n    // printQueue function \r\n    // prints all the element of the queue \r\n    printPQueue() \r\n    { \r\n        var str = \"\"; \r\n        for (var i = 0; i < this.items.length; i++) \r\n            str += this.items[i].element + \" \"; \r\n        return str; \r\n    } \r\n} \r\n\r\nexport default PriorityQueue;","import PriorityQueue from \"../Utils\";\r\n\r\n// Pathfinding algorithms\r\nexport const pathfindAlgorithms = {\r\n    DIJKSTRA: \"dijkstra\",\r\n    ASTAR: \"astar\",\r\n    BFS: \"bfs\",\r\n    DFS: \"dfs\",\r\n}\r\n\r\n/**\r\n * Executes a Dijkstra's algorithm search.\r\n * \r\n * @param {Array} grid grid of nodes\r\n * @param {Node} start start node\r\n * @param {Node} target target node\r\n * \r\n * @returns an array of visited nodes in order\r\n */\r\nexport function dijkstra(grid, start, target) {\r\n    const visitedNodes = [];\r\n    const unvisitedNodes = getAllNodes(grid);\r\n    start.distance = 0;\r\n    while (unvisitedNodes.length !== 0) {\r\n        unvisitedNodes.sort((a, b) => a.distance - b.distance);\r\n        const curNode = unvisitedNodes.shift();\r\n        \r\n        if (!curNode) break;\r\n        if (curNode.isWall) continue;\r\n        if (curNode.distance === Infinity) return visitedNodes;\r\n\r\n        curNode.isVisited = true;\r\n        visitedNodes.push(curNode);\r\n\r\n        if (curNode === target) return visitedNodes;\r\n\r\n        const unvisitedNeighbors = getUnvisitedNeighbors(curNode, grid);\r\n        for (const neighbor of unvisitedNeighbors) {\r\n            neighbor.distance = curNode.distance + neighbor.cost;\r\n            neighbor.previousNode = curNode;\r\n        }\r\n    }\r\n    return visitedNodes;\r\n}\r\n\r\n/**\r\n * Executes an A* (A-Star) algorithm search.\r\n * \r\n * @param {Array} grid grid of nodes\r\n * @param {Node} start start node\r\n * @param {Node} target target node\r\n * \r\n * @returns an array of visited nodes in order\r\n */\r\nexport function aStar(grid, start, target) {\r\n    const visitedNodes = [];\r\n    const unvisitedNodes = new PriorityQueue();\r\n    unvisitedNodes.enqueue(start, 0);\r\n    start.distance = 0;\r\n    start.rootDistance = 0;\r\n    while (!unvisitedNodes.isEmpty()) {\r\n        const curNode = unvisitedNodes.dequeue().element;\r\n\r\n        if (curNode.isWall) continue;\r\n        if (curNode.distance === Infinity) return visitedNodes;\r\n\r\n        curNode.isVisited = true;\r\n        visitedNodes.push(curNode);\r\n\r\n        if (curNode === target) return visitedNodes;\r\n\r\n        const unvisitedNeighbors = getUnvisitedNeighbors(curNode, grid);\r\n        for (const neighbor of unvisitedNeighbors) {\r\n            const manhattanD = 2 * (Math.abs(target.row - neighbor.row) + (Math.abs(target.col - neighbor.col)));\r\n            neighbor.rootDistance = Math.min(neighbor.rootDistance, curNode.rootDistance + neighbor.cost);\r\n            const minDistance = Math.min(neighbor.distance, neighbor.rootDistance + manhattanD);\r\n            if (minDistance !== neighbor.distance) {\r\n                neighbor.distance = minDistance;\r\n                neighbor.previousNode = curNode;\r\n                if (unvisitedNodes.contains(neighbor)) unvisitedNodes.setPriority(neighbor, minDistance);\r\n            }\r\n            if (!unvisitedNodes.contains(neighbor)) unvisitedNodes.enqueue(neighbor, neighbor.distance);\r\n        }\r\n    }\r\n    return visitedNodes;\r\n}\r\n\r\n/**\r\n * Executes Breadth First Search (BFS) algorithm search.\r\n * \r\n * @param {Array} grid grid of nodes\r\n * @param {Node} start start node\r\n * @param {Node} target target node\r\n * \r\n * @returns an array of visited nodes in order\r\n */\r\nexport function breadthFirstSearch(grid, start, target) {\r\n    const visitedNodes = [];\r\n    const unvisitedNodes = [start];\r\n    start.distance = 0;\r\n    while (unvisitedNodes.length !== 0) {\r\n        const curNode = unvisitedNodes.shift();\r\n\r\n        if (curNode.isWall) continue;\r\n        if (curNode.isVisited) continue;\r\n\r\n        if (curNode.distance === Infinity) return visitedNodes;\r\n        if (curNode === target) return visitedNodes; \r\n\r\n        const unvisitedNeighbors = getUnvisitedNeighbors(curNode, grid);\r\n        for (const neighbor of unvisitedNeighbors) {\r\n            unvisitedNodes.push(neighbor);\r\n            curNode.isVisited = true;\r\n            visitedNodes.push(curNode);\r\n\r\n            neighbor.distance = curNode.distance + 1;\r\n            neighbor.previousNode = curNode;\r\n        }\r\n    }\r\n    return visitedNodes;\r\n}\r\n\r\n/**\r\n * Executes a Depth First Search (DFS) algorithm search.\r\n * \r\n * @param {Array} grid grid of nodes\r\n * @param {Node} start start node\r\n * @param {Node} target target node\r\n * \r\n * @returns an array of visited nodes in order\r\n */\r\nexport function depthFirstSearch(grid, start, target) {\r\n    const visitedNodes = [];\r\n    const unvisitedNodes = [start];\r\n    start.distance = 0;\r\n    while (unvisitedNodes.length !== 0) {\r\n        const curNode = unvisitedNodes.pop();\r\n\r\n        if (curNode.isWall) continue;\r\n        if (curNode.isVisited) continue;\r\n\r\n        if (curNode.distance === Infinity) return visitedNodes;\r\n        if (curNode === target) return visitedNodes;\r\n\r\n        const unvisitedNeighbors = getUnvisitedNeighbors(curNode, grid);\r\n        for (const neighbor of unvisitedNeighbors) {\r\n            unvisitedNodes.push(neighbor);\r\n            curNode.isVisited = true;\r\n            visitedNodes.push(curNode);\r\n\r\n            neighbor.distance = curNode.distance + 1;\r\n            neighbor.previousNode = curNode;\r\n        }\r\n    }\r\n    return visitedNodes;\r\n}\r\n\r\n/**\r\n * Gets all of the nodes in the grid.\r\n * \r\n * @param {Array} grid grid of nodes\r\n * \r\n * @returns an array containing all of the nodes\r\n */\r\nfunction getAllNodes(grid) {\r\n    const nodes = [];\r\n    for (const row of grid) {\r\n        for (const node of row) nodes.push(node);\r\n    }\r\n    return nodes;\r\n}\r\n\r\n/**\r\n * Gets the shortest path of nodes from the target node to \r\n * the start node.\r\n * \r\n * @param {Node} targetNode target node\r\n * \r\n * @returns an array of shortest path nodes in order\r\n */\r\nexport function getShortestPathNodes(targetNode) {\r\n    const nodesInShortestPath = [];\r\n    let currentNode = targetNode;\r\n    while (currentNode !== null) {\r\n        nodesInShortestPath.unshift(currentNode);\r\n        currentNode = currentNode.previousNode;\r\n    }\r\n    return nodesInShortestPath;\r\n}\r\n\r\n/**\r\n * Gets all unvisited neighbors of a given node.\r\n * \r\n * @param {Node} node node\r\n * @param {Array} grid grid of nodes\r\n * \r\n * @returns an array containing all unvisited neighbors\r\n */\r\nfunction getUnvisitedNeighbors(node, grid) {\r\n    const neighbors = [];\r\n    const {row, col} = node;\r\n    \r\n    if (col > 0) neighbors.push(grid[row][col - 1]); // West\r\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]); // South\r\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]); // East\r\n    if (row > 0) neighbors.push(grid[row - 1][col]); // North\r\n    \r\n    return neighbors.filter(neighbor => !neighbor.isVisited);\r\n}","import { random } from '../Utils';\r\n\r\n/**\r\n * Algorithm for generating a maze using recursive devision.\r\n * \r\n * @param {int} rows number of rows\r\n * @param {int} cols number of columns\r\n * \r\n * @returns a grid of boolean values, true if wall node\r\n */\r\nexport function recursiveDevision(rows, cols) {\r\n    var walls = [];\r\n\r\n    //walls = innerWalls(walls, true, 0, cols-1, 0, rows-1);\r\n    walls = buildWalls(walls, rows, cols);\r\n    \r\n    return walls;\r\n}\r\n\r\n/**\r\n * Creates walls around the border of the maze.\r\n * \r\n * @param {Array} walls grid of walls\r\n * @param {int} rows amount of rows \r\n * @param {int} cols amount of columns\r\n * \r\n * @returns a grid of walls\r\n */\r\nfunction buildWalls(walls, rows, cols) {\r\n    for (var r = 0; r < rows; r++) {\r\n        if (r === 0 || r === (rows-1)) {\r\n            for (var c = 0; c < cols; c++) {\r\n                walls.push([r, c]);\r\n            }\r\n        } else {\r\n            walls.push([r, 0]);\r\n            walls.push([r, cols-1]);\r\n        }\r\n    }\r\n\r\n    walls = innerWalls(walls, true, 1, cols-2, 1, rows-2);\r\n    return walls;\r\n}\r\n\r\n/**\r\n * Recursive function that builds the inner walls of the maze.\r\n * \r\n * @param {Array} walls grid of walls\r\n * @param {boolean} h is horizontal wall\r\n * @param {int} minC lower column bound\r\n * @param {int} maxC upper column bound\r\n * @param {int} minR lower row bound\r\n * @param {int} maxR upper row bound\r\n * \r\n * @returns a grid of walls\r\n */\r\nfunction innerWalls(walls, h, minC, maxC, minR, maxR) {\r\n    if (h) {\r\n        if (maxC - minC <= 1) { return walls; }\r\n\r\n        var r = Math.floor(random(minR, maxR)/2)*2;\r\n        walls = addHWall(walls, minC, maxC, r);\r\n\r\n        walls = innerWalls(walls, !h, minC, maxC, minR, r-1);\r\n        walls = innerWalls(walls, !h, minC, maxC, r+1, maxR);\r\n    } else {\r\n        if (maxR - minR <= 1) { return walls; }\r\n\r\n        var c = Math.floor(random(minC, maxC)/2)*2;\r\n        walls = addVWall(walls, minR, maxR, c);\r\n\r\n        walls = innerWalls(walls, !h, minC, c-1, minR, maxR);\r\n        walls = innerWalls(walls, !h, c+1, maxC, minR, maxR);\r\n    }\r\n    return walls;\r\n}\r\n\r\n/**\r\n * Builds a horizontal wall at a given row.\r\n * \r\n * @param {Array} walls grid of walls\r\n * @param {int} minC lower column bound\r\n * @param {int} maxC upper column bound\r\n * @param {int} r row\r\n */\r\nfunction addHWall(walls, minC, maxC, r) {\r\n    var hole = Math.floor(random(minC, maxC)/2)*2+1;\r\n    for (var i = minC; i <= maxC; i++) { if (i !== hole) walls.push([r, i]); }\r\n    return walls;\r\n}\r\n\r\n/**\r\n * Builds a vertical wall at a given column.\r\n * \r\n * @param {Array} walls grid of walls\r\n * @param {int} minR lower row bound\r\n * @param {int} maxR upper row bound\r\n * @param {int} c column \r\n */\r\nfunction addVWall(walls, minR, maxR, c) {\r\n    var hole = Math.floor(random(minR, maxR)/2)*2+1;\r\n    for (var i = minR; i <= maxR; i++) { if (i !== hole) walls.push([i, c]); }\r\n    return walls;\r\n}","import React from 'react';\r\nimport { Container, Row, Col, Button, ButtonDropdown, DropdownItem, DropdownToggle, DropdownMenu\r\n} from 'reactstrap';\r\n\r\nimport { pathfindAlgorithms } from './PathfindAlgorithms';\r\n\r\n/**\r\n * Represents the top menu of the pathfinding visualizer component.\r\n * \r\n * @author Jake Waclawski\r\n */\r\nclass PathfindMenu extends React.Component {\r\n    constructor (props) {\r\n        super(props);\r\n        this.state = {\r\n            // Visualize button dropdown status\r\n            visualizeDropdownOpen: false,\r\n            // Edit button dropdown status\r\n            editDropdownOpen: false,\r\n            // Maze button dropdown status\r\n            mazeDropdownOpen: false,\r\n            // Clear button dropdown status\r\n            clearDropdownOpen: false,\r\n            // Display path instantly?\r\n            isInstant: false,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Toggles the visualize button dropdown.\r\n     */\r\n    toggleVisualize () { this.setState({visualizeDropdownOpen: !this.state.visualizeDropdownOpen}); }\r\n\r\n    /**\r\n     * Toggles the edit button dropdown.\r\n     */\r\n    toggleEdit () { this.setState({editDropdownOpen: !this.state.editDropdownOpen}); }\r\n\r\n    /**\r\n     * Toggles the maze button dropdown.\r\n     */\r\n    toggleMaze () { this.setState({mazeDropdownOpen: !this.state.mazeDropdownOpen}); }\r\n\r\n    /**\r\n     * Toggles the clear button dropdown.\r\n     */\r\n    toggleClear () { this.setState({clearDropdownOpen: !this.state.clearDropdownOpen}); }\r\n\r\n    /**\r\n     * Toggles if the path should be displayed instantly.\r\n     */\r\n    toggleInstant () { this.setState({isInstant: !this.state.isInstant}); }\r\n\r\n    /**\r\n     * Get the current text of the visualize button.\r\n     */\r\n    getIsInstantText () { return this.state.isInstant ? \"Instant\" : \"Visualize\"; }\r\n \r\n    /**\r\n     * Renders the menu component.\r\n     * \r\n     * @returns a <div> element representing the menu\r\n     */\r\n    render () {\r\n        return (\r\n            <div className=\"pathfind-menu\">\r\n                <Container>\r\n                    <Row>\r\n                        <Col className=\"title\">\r\n                            Pathfinding Visualizer\r\n                        </Col>\r\n                        <Col>\r\n                            <Container>\r\n                                <Row>\r\n                                    <Col>\r\n                                        <ButtonDropdown isOpen={this.state.visualizeDropdownOpen} toggle={() => this.toggleVisualize()}>\r\n                                            <Button color=\"success\" onClick={() => this.toggleVisualize()}>{this.getIsInstantText()}</Button>\r\n                                            <DropdownToggle split color=\"success\" />\r\n                                            <DropdownMenu>\r\n                                                <DropdownItem onClick={() => this.toggleInstant()}>Pathfind Mode</DropdownItem>\r\n                                                <DropdownItem divider />\r\n                                                <DropdownItem onClick={() => this.props.pathfinder.visualizePathfind(pathfindAlgorithms.DIJKSTRA, this.state.isInstant)}>Dijkstra</DropdownItem>\r\n                                                <DropdownItem onClick={() => this.props.pathfinder.visualizePathfind(pathfindAlgorithms.ASTAR, this.state.isInstant)}>A* (A-Star)</DropdownItem>\r\n                                                <DropdownItem onClick={() => this.props.pathfinder.visualizePathfind(pathfindAlgorithms.BFS, this.state.isInstant)}>Breadth First Search</DropdownItem>\r\n                                                <DropdownItem onClick={() => this.props.pathfinder.visualizePathfind(pathfindAlgorithms.DFS, this.state.isInstant)}>Depth First Search</DropdownItem>\r\n                                            </DropdownMenu>\r\n                                        </ButtonDropdown>\r\n                                    </Col>\r\n                                    <Col>\r\n                                        <ButtonDropdown isOpen={this.state.editDropdownOpen} toggle={() => this.toggleEdit()}>\r\n                                            <Button color=\"info\" onClick={() => this.toggleEdit()}>Edit</Button>\r\n                                            <DropdownToggle split color=\"info\" />\r\n                                            <DropdownMenu>\r\n                                                <DropdownItem onClick={() => this.props.pathfinder.setDrawMode(0)}>Stop Drawing</DropdownItem>\r\n                                                <DropdownItem divider />\r\n                                                <DropdownItem onClick={() => this.props.pathfinder.setDrawMode(1)}>Draw Walls</DropdownItem>\r\n                                                <DropdownItem onClick={() => this.props.pathfinder.setDrawMode(2)}>Draw Weights</DropdownItem>\r\n                                                <DropdownItem divider />\r\n                                                <DropdownItem onClick={() => this.props.pathfinder.resetStartTarget()}>Reset Start/Target Nodes</DropdownItem>\r\n                                                <DropdownItem divider />\r\n                                                <DropdownItem onClick={() => this.props.pathfinder.placeStartNode()}>Place Start Node</DropdownItem>\r\n                                                <DropdownItem onClick={() => this.props.pathfinder.placeTargetNode()}>Place Target Node</DropdownItem>\r\n                                            </DropdownMenu>\r\n                                        </ButtonDropdown>\r\n                                    </Col>\r\n                                    <Col>\r\n                                        <ButtonDropdown isOpen={this.state.mazeDropdownOpen} toggle={() => this.toggleMaze()}>\r\n                                            <Button color=\"warning\" onClick={() => this.toggleMaze()}>Maze</Button>\r\n                                            <DropdownToggle split color=\"warning\" />\r\n                                            <DropdownMenu>\r\n                                                <DropdownItem onClick={() => this.props.pathfinder.animateMaze()}>Recursive Devision</DropdownItem>\r\n                                            </DropdownMenu>\r\n                                        </ButtonDropdown>\r\n                                    </Col>\r\n                                    <Col>\r\n                                        <ButtonDropdown isOpen={this.state.clearDropdownOpen} toggle={() => this.toggleClear()}>\r\n                                            <Button color=\"danger\" onClick={() => this.toggleClear()}>Clear</Button>\r\n                                            <DropdownToggle split color=\"danger\" />\r\n                                            <DropdownMenu>\r\n                                                <DropdownItem onClick={() => this.props.pathfinder.clearGrid()}>Clear All</DropdownItem>\r\n                                                <DropdownItem divider />\r\n                                                <DropdownItem onClick={() => this.props.pathfinder.clearWeights()}>Clear Weights</DropdownItem>\r\n                                                <DropdownItem onClick={() => this.props.pathfinder.clearWalls()}>Clear Walls</DropdownItem>\r\n                                                <DropdownItem onClick={() => this.props.pathfinder.clearPaths()}>Clear Path</DropdownItem>\r\n                                            </DropdownMenu>\r\n                                        </ButtonDropdown>\r\n                                    </Col>\r\n                                </Row>\r\n                            </Container>\r\n                        </Col>\r\n                    </Row>\r\n                </Container>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default PathfindMenu;","import React from 'react';\r\n\r\nimport './Node.css';\r\n\r\n/**\r\n * Represents a grid node on the screen. Extra class names\r\n * can be applied to change the appearance of the node.\r\n * \r\n * @author Jake Waclawski\r\n */\r\nclass Node extends React.Component {\r\n    constructor (props) {\r\n        super(props);\r\n        this.state = {};\r\n    }\r\n\r\n    /**\r\n     * Renders the node.\r\n     * \r\n     * @returns a <div> element representing the node\r\n     */\r\n    render () {\r\n        const nodeType = this.props.isStart ? 'start' : \r\n        this.props.isTarget ? 'target' : \r\n        this.props.isWall ? 'wall' :\r\n        this.props.cost > 1 ? 'weight' :\r\n        '';\r\n\r\n        return (\r\n            <div \r\n            id={`node-${this.props.row}-${this.props.col}`} \r\n            className={`node ${nodeType}`}\r\n            onMouseDown={() => this.props.mousePressed(this.props.row, this.props.col, this.props.isWall)}\r\n            onMouseEnter={() => this.props.mouseEntered(this.props.row, this.props.col, this.props.isWall)}\r\n            /> \r\n        );\r\n    }\r\n}\r\n\r\nexport default Node;","import React from 'react';\r\n\r\nimport './PathfindingVisualizer.css';\r\n\r\nimport { getShortestPathNodes, dijkstra, aStar, breadthFirstSearch, depthFirstSearch, pathfindAlgorithms\r\n} from './PathfindAlgorithms';\r\nimport { recursiveDevision\r\n} from './MazeAlgorithms';\r\nimport PathfindMenu from './PathfindMenu';\r\nimport Node from './Node';\r\n\r\n// Number of rows in the grid\r\nconst ROW_COUNT = 29;\r\n// Number of columns in the grid\r\nconst COL_COUNT = 71;\r\n// Initial cost of weighted nodes\r\nconst INIT_COST = 15;\r\n// Initial coordinates of the start node [row, col]\r\nconst INIT_START = [14, 10];\r\n// Initial coordinates of the target noe [row, col]\r\nconst INIT_TARGET = [14, 60];\r\n// Speed between visited node animations in miliseconds\r\nconst SPEED = 5;\r\n\r\n// Node class types\r\nconst nodeTypes = {\r\n    NODE: 'node',\r\n    WALL: 'node wall',\r\n    WEIGHT: 'node weight',\r\n    START: 'node start',\r\n    TARGET: 'node target',\r\n    VISITED: 'node visited',\r\n    VISITED_WEIGHT: 'node visited-weight',\r\n    VISITED_WEIGHT_INSTANT: 'node visited-weight-instant',\r\n    PATH: 'node path',\r\n    PATH_WEIGHT: 'node path-weight',\r\n    VISITED_INSTANT: 'node visited-instant',\r\n}\r\n\r\n/**\r\n * Represents the pathfinding visualizer component.\r\n * \r\n * @author Jake Waclawski\r\n */\r\nclass PathfindingVisualizer extends React.Component {\r\n    constructor (props) {\r\n        super(props);\r\n        this.state = {\r\n            // Current state of grid nodes\r\n            grid: [],\r\n            // Current cost of weighted nodes\r\n            weightCost: INIT_COST,\r\n            // Is the mouse down?\r\n            mouseIsDown: false,\r\n            // Current draw mode (0: none, 1: walls, 2: weights)\r\n            drawMode: 0,\r\n            // Are we erasing or drawing walls (null if neither)?\r\n            drawWall: null,\r\n            // Are we erasing or drawing weights (null if neither)?\r\n            drawWeight: null,\r\n            // Are we placing the start node?\r\n            placingStart: false,\r\n            // Are we placing the target node?\r\n            placingTarget: false,\r\n            // Current start node position\r\n            startNode: INIT_START,\r\n            // Current target node position\r\n            targetNode: INIT_TARGET,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the grid with new nodes. Start and target\r\n     * node positions are preserved.\r\n     * \r\n     * @returns new grid of nodes\r\n     */\r\n    rebuildGrid () {\r\n        const grid = [];\r\n        for (let r = 0; r < ROW_COUNT; r++) {\r\n            const curRow = [];\r\n            for (let c = 0; c < COL_COUNT; c++) {\r\n                curRow.push(this.createNode(r, c, 1, false));\r\n            }\r\n            grid.push(curRow);\r\n        }\r\n        return grid;\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the grid with new nodes. Main node types are\r\n     * preserved (start, target, wall, weight).\r\n     * \r\n     * @returns new grid of nodes\r\n     */\r\n    softRebuildGrid () {\r\n        const oldGrid = this.state.grid;\r\n        const grid = [];\r\n        for (let r = 0; r < ROW_COUNT; r++) {\r\n            const curRow = [];\r\n            for (let c = 0; c < COL_COUNT; c++) {\r\n                curRow.push(this.createNode(r, c, oldGrid[r][c].cost, oldGrid[r][c].isWall));\r\n            }\r\n            grid.push(curRow);\r\n        }\r\n        return grid;\r\n    }\r\n\r\n    /**\r\n     * Creates a new node with stored properties.\r\n     * \r\n     * @param {int} row row on grid\r\n     * @param {int} col column on grid\r\n     * @param {int} cost weight cost of node\r\n     * @param {boolean} isWall is node a wall\r\n     */\r\n    createNode (row, col, cost, isWall) {\r\n        return {\r\n            row: row,\r\n            col: col,\r\n            cost: cost,\r\n            distance: Infinity,\r\n            rootDistance: Infinity,\r\n            isStart: row === this.state.startNode[0] && col === this.state.startNode[1],\r\n            isTarget: row === this.state.targetNode[0] && col === this.state.targetNode[1],\r\n            isWall: isWall,\r\n            previousNode: null,\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Updates the visual weight state of a given node.\r\n     * \r\n     * @param {int} row row of node on grid\r\n     * @param {int} col column of node on grid\r\n     * @param {int} isWeight is new type weight node\r\n     */\r\n    drawWeightNode (row, col, isWeight) {\r\n        const nodeElement = document.getElementById(`node-${row}-${col}`);\r\n        const node = this.state.grid[row][col];\r\n\r\n        if (node.isWall || node.isStart || node.isTarget) return;\r\n\r\n        if (isWeight) nodeElement.className = nodeTypes.WEIGHT;\r\n        else nodeElement.className = nodeTypes.NODE;\r\n    }\r\n\r\n    /**\r\n     * Updates the visual wall state of a given node. \r\n     * \r\n     * @param {int} row row of node on grid\r\n     * @param {int} col column of node on grid\r\n     * @param {boolean} isWall is new type wall node\r\n     */\r\n    drawWallNode (row, col, isWall) {\r\n        const nodeElement = document.getElementById(`node-${row}-${col}`);\r\n        const node = this.state.grid[row][col];\r\n\r\n        if (node.isStart || node.isTarget) return;\r\n\r\n        if (isWall) nodeElement.className = nodeTypes.WALL;\r\n        else nodeElement.className = nodeTypes.NODE;\r\n    }\r\n\r\n    /**\r\n     * Updates the state of the grid of nodes. Changes the properties of\r\n     * newly drawn node types according to their current visual state.\r\n     */\r\n    updateGrid () {\r\n        const grid = this.state.grid;\r\n\r\n        for (let r = 0; r < grid.length; r++) {\r\n            for (let c = 0; c < grid[0].length; c++) {\r\n                const nodeElement = document.getElementById(`node-${r}-${c}`);\r\n                const node = grid[r][c];\r\n\r\n                switch (nodeElement.className) {\r\n                    case nodeTypes.NODE:\r\n                        node.isWall = false;\r\n                        node.cost = 1;\r\n                        break;\r\n                    case nodeTypes.WALL:\r\n                        node.isWall = true;\r\n                        break;\r\n                    case nodeTypes.WEIGHT:\r\n                        node.cost = this.state.weightCost;\r\n                        break;\r\n                    default:\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n\r\n        this.setState({grid: grid});\r\n    }\r\n\r\n    /**\r\n     * Sets new start node position. Updates state, we are no\r\n     * longer placing the start node.\r\n     * \r\n     * @param {int} row row on grid\r\n     * @param {int} col column on grid\r\n     */\r\n    setStartNode (row, col) { \r\n        const grid = this.state.grid;\r\n        const curStart = this.state.grid[this.state.startNode[0]][this.state.startNode[1]];\r\n        const curStartNew = {\r\n            ...curStart,\r\n            isStart: false,\r\n        }\r\n        grid[this.state.startNode[0]][this.state.startNode[1]] = curStartNew;\r\n\r\n        this.setState({startNode: [row, col]}); \r\n        \r\n        const node = this.state.grid[row][col];\r\n        const newNode = {\r\n            ...node,\r\n            isWall: false,\r\n            isStart: true,\r\n        }\r\n        grid[row][col] = newNode;\r\n\r\n        this.setState({\r\n            grid: grid,\r\n            placingStart: false,\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Sets new target node position. Updates state, we are no\r\n     * longer placing the target node.\r\n     * \r\n     * @param {int} row row on grid \r\n     * @param {int} col column on grid\r\n     */\r\n    setTargetNode (row, col) { \r\n        const grid = this.state.grid;\r\n        const curTarget = this.state.grid[this.state.targetNode[0]][this.state.targetNode[1]];\r\n        const curTargetNew = {\r\n            ...curTarget,\r\n            isTarget: false,\r\n        }\r\n        grid[this.state.targetNode[0]][this.state.targetNode[1]] = curTargetNew;\r\n\r\n        this.setState({targetNode: [row, col]}); \r\n    \r\n        const node = this.state.grid[row][col];\r\n        const newNode = {\r\n            ...node,\r\n            isWall: false,\r\n            isTarget: true,\r\n        }\r\n        grid[row][col] = newNode;\r\n        \r\n        this.setState({\r\n            grid: grid,\r\n            placingTarget: false,\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Clears the entire grid.\r\n     */\r\n    clearGrid () {\r\n        this.clearWeights();\r\n        this.clearWalls();\r\n        this.clearPaths();\r\n    }\r\n\r\n    /**\r\n     * Clears the grid of all wall nodes.\r\n     */\r\n    clearWalls () { \r\n        const grid = this.state.grid;\r\n        for (const row of grid) {\r\n            for (const node of row) {\r\n                if (node.isWall) node.isWall = false;\r\n            }\r\n        }\r\n        this.setState({grid: grid});\r\n    }\r\n\r\n    /**\r\n     * Clears the grid of all weighted nodes and resets their\r\n     * costs to 1.\r\n     */\r\n    clearWeights () {\r\n        const grid = this.state.grid;\r\n\r\n        for (const row of grid) {\r\n            for (const node of row) {\r\n                if (node.cost !== 1) node.cost = 1;\r\n            }\r\n        }\r\n\r\n        this.setState({grid: grid});\r\n    }\r\n\r\n    /**\r\n     * Clears the visual grid of all path and visited type nodes.\r\n     * Updates the class name of each appropriate node object.\r\n     */\r\n    clearPaths () {\r\n        for (let r = 0; r < ROW_COUNT; r++) {\r\n            for (let c = 0; c < COL_COUNT; c++) {\r\n                const nodeElement = document.getElementById(`node-${r}-${c}`);\r\n\r\n                if (nodeElement.className === nodeTypes.VISITED || nodeElement.className === nodeTypes.PATH || nodeElement.className === nodeTypes.VISITED_INSTANT) {\r\n                    nodeElement.className = nodeTypes.NODE;\r\n                }\r\n                else if (nodeElement.className === nodeTypes.VISITED_WEIGHT || nodeElement.className === nodeTypes.PATH_WEIGHT) {\r\n                    nodeElement.className = nodeTypes.WEIGHT;\r\n                }\r\n            }\r\n        }\r\n\r\n        this.setState({grid: this.softRebuildGrid()})\r\n    }\r\n\r\n    /**\r\n     * Resets the start and target nodes to their initial locations.\r\n     */\r\n    resetStartTarget () {\r\n        this.setStartNode(INIT_START[0], INIT_START[1]);\r\n        this.setTargetNode(INIT_TARGET[0], INIT_TARGET[1]);\r\n    }\r\n\r\n    /**\r\n     * Sets new cost of weighted nodes.\r\n     * \r\n     * @param {int} weight new cost\r\n     */\r\n    setNewWeight (weight) { this.setState({weightCost: weight}); }\r\n\r\n    /**\r\n     * Updates the state, we are now placing the start node.\r\n     */\r\n    placeStartNode () { this.setState({placingStart: true}); }\r\n    \r\n    /**\r\n     * Updates the state, we are now placing the target node.\r\n     */\r\n    placeTargetNode () { this.setState({placingTarget: true}); }\r\n\r\n    /**\r\n     * Sets the current draw mode.\r\n     * 0: none\r\n     * 1: walls\r\n     * 2: weights\r\n     * \r\n     * @param {int} mode new draw mode\r\n     */\r\n    setDrawMode (mode) { this.setState({drawMode: mode}); }\r\n\r\n    /**\r\n     * Visualizes a given pathfinding algorithm. Uses the current state of\r\n     * the grid of nodes.\r\n     * \r\n     * @param {pathfindAlgorithms} algorithm pathfinding algorithm\r\n     * @param {boolean} isInstant true if displaying instantly\r\n     */\r\n    visualizePathfind (algorithm, isInstant) {\r\n        this.updateGrid();\r\n        this.clearPaths();\r\n\r\n        const grid = this.state.grid;\r\n        const start = grid[this.state.startNode[0]][this.state.startNode[1]];\r\n        const target = grid[this.state.targetNode[0]][this.state.targetNode[1]];\r\n\r\n        var visitedNodes = [];\r\n        switch (algorithm) {\r\n            case pathfindAlgorithms.DIJKSTRA:\r\n                visitedNodes = dijkstra(grid, start, target);\r\n                break;\r\n            case pathfindAlgorithms.ASTAR:\r\n                visitedNodes = aStar(grid, start, target);\r\n                break;\r\n            case pathfindAlgorithms.BFS:\r\n                visitedNodes = breadthFirstSearch(grid, start, target);\r\n                break;\r\n            case pathfindAlgorithms.DFS:\r\n                visitedNodes = depthFirstSearch(grid, start, target);\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n        \r\n        const shortestPath = getShortestPathNodes(target);\r\n\r\n        this.animateSearch(visitedNodes, shortestPath, isInstant);\r\n    }\r\n\r\n    /**\r\n     * Animates the process of the pathfinding algorithm. Updates the class\r\n     * names of the nodes to change their appearance.\r\n     * \r\n     * @param {Array} visitedNodes array of visited nodes in order\r\n     * @param {Array} shortestPath array of shortest path nodes in order\r\n     * @param {boolean} isInstant true if displaying instantly\r\n     */\r\n    animateSearch (visitedNodes, shortestPath, isInstant) {\r\n        if (isInstant) {\r\n            for (let i = 0; i <= visitedNodes.length; i++) {\r\n                if (i === visitedNodes.length) {\r\n                    for (let i = 1; i < shortestPath.length - 1; i++) {\r\n                        const node = shortestPath[i];\r\n                        const nodeElement = document.getElementById(`node-${node.row}-${node.col}`);\r\n\r\n                        if (!node.isStart && !node.isTarget) {\r\n                            if (node.cost !== 1) nodeElement.className = nodeTypes.PATH_WEIGHT;\r\n                            else nodeElement.className = nodeTypes.PATH;\r\n                        }\r\n                    }\r\n                    return;\r\n                }\r\n                const node = visitedNodes[i];\r\n                const nodeElement = document.getElementById(`node-${node.row}-${node.col}`);\r\n\r\n                if(!node.isStart && !node.isTarget) {\r\n                    if (node.cost !== 1) nodeElement.className = nodeTypes.VISITED_WEIGHT_INSTANT;\r\n                    else nodeElement.className = nodeTypes.VISITED_INSTANT;\r\n                }\r\n            }\r\n        } else {\r\n            for (let i = 0; i <= visitedNodes.length; i++) {\r\n                if (i === visitedNodes.length) {\r\n                    setTimeout(() => {\r\n                        this.animatePath(shortestPath);\r\n                    }, SPEED * i);\r\n                    return;\r\n                }\r\n                setTimeout(() => {\r\n                    const node = visitedNodes[i];\r\n                    const nodeElement = document.getElementById(`node-${node.row}-${node.col}`);\r\n\r\n                    if(!node.isStart && !node.isTarget) { \r\n                        if (node.cost !== 1) nodeElement.className = nodeTypes.VISITED_WEIGHT;\r\n                        else nodeElement.className = nodeTypes.VISITED;\r\n                    }\r\n                }, SPEED * i);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Animates the shortest path from the start node to the target node.\r\n     * Updates the class names of the nodes to change their appearance.\r\n     * \r\n     * @param {Array} shortestPath array of shortest path nodes in order \r\n     */\r\n    animatePath (shortestPath) {\r\n        for (let i = 0; i < shortestPath.length; i++) {\r\n            setTimeout(() => {\r\n                const node = shortestPath[i];\r\n                const nodeElement = document.getElementById(`node-${node.row}-${node.col}`);\r\n\r\n                if (!node.isStart && !node.isTarget) {\r\n                    if (node.cost !== 1) nodeElement.className = nodeTypes.PATH_WEIGHT;\r\n                    else nodeElement.className = nodeTypes.PATH;\r\n                }\r\n            }, 50 * i);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Animates a generated maze.\r\n     */\r\n    animateMaze () {\r\n        this.clearWalls();\r\n        const maze = recursiveDevision(ROW_COUNT, COL_COUNT);\r\n\r\n        for (let i = 0; i < maze.length; i++) {\r\n            setTimeout(() => {\r\n                this.drawWallNode(maze[i][0], maze[i][1], true);\r\n            }, 10 * i);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Runs on page load. Rebuilds the grid.\r\n     */\r\n    componentDidMount () {\r\n        const grid = this.rebuildGrid();\r\n        this.setState({grid: grid});\r\n    }\r\n\r\n    /**\r\n     * Handles a mouse down event on a node. If we are placing the start or\r\n     * target node, update the node location and return. Otherwise, updates\r\n     * the node based on the current draw mode.\r\n     * 0: none\r\n     * 1: walls\r\n     * 2: weights\r\n     * \r\n     * @param {int} row row of node on grid\r\n     * @param {int} col column of node on grid\r\n     */\r\n    handleMouseDown (row, col) {\r\n        if (this.state.placingStart) {\r\n            this.setStartNode(row, col);\r\n            return;\r\n        }\r\n\r\n        if (this.state.placingTarget) {\r\n            this.setTargetNode(row, col);\r\n            return;\r\n        }\r\n\r\n        const grid = this.state.grid;\r\n\r\n        switch (this.state.drawMode) {\r\n            case 0:\r\n                break;\r\n            case 1:\r\n                const isWall = grid[row][col].isWall;\r\n                this.drawWallNode(row, col, !isWall);\r\n                this.setState({drawWall: !isWall});\r\n                break;\r\n            case 2:\r\n                const isWeight = grid[row][col].cost !== 1;\r\n                this.drawWeightNode(row, col, !isWeight);\r\n                this.setState({drawWeight: !isWeight});\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n        this.setState({mouseIsDown: true});\r\n    }\r\n\r\n    /**\r\n     * Handles a mouse up event. Sets the state so that nothing\r\n     * can be drawn.\r\n     */\r\n    handleMouseUp () {\r\n        if (!this.state.mouseIsDown) return;\r\n\r\n        this.updateGrid();\r\n\r\n        this.setState({\r\n            mouseIsDown: false,\r\n            drawWall: null,\r\n            drawWeight: null,\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Handles a mouse enter event into a node. If the mouse is not down,\r\n     * return. Otherwise, updates the node based on the current draw mode.\r\n     * 0: none\r\n     * 1: walls\r\n     * 2: weights\r\n     * \r\n     * @param {int} row row of node on grid\r\n     * @param {int} col column of node on grid\r\n     */\r\n    handleMouseEnter (row, col) {\r\n        if (!this.state.mouseIsDown) return;\r\n\r\n        const grid = this.state.grid;\r\n\r\n        switch (this.state.drawMode) {\r\n            case 0: \r\n                break;\r\n            case 1:\r\n                const isWall = grid[row][col].isWall;\r\n                if (isWall !== this.state.drawWall) this.drawWallNode(row, col, !isWall);\r\n                break;\r\n            case 2:\r\n                const isWeight = grid[row][col].cost !== 1;\r\n                if (isWeight !== this.state.drawWeight) this.drawWeightNode(row, col, !isWeight);\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Renders the pathfinding visualizer component.\r\n     * \r\n     * @returns a <div> element representing the component\r\n     */\r\n    render () {\r\n        //console.log(this.state.grid);\r\n\r\n        return (\r\n            <div className=\"pathfind-vis\">\r\n                <div className=\"pathfind-menu\">\r\n                    <PathfindMenu pathfinder={this} />\r\n                </div>\r\n                <div \r\n                className=\"grid\" \r\n                onMouseUp={() => this.handleMouseUp()}\r\n                onMouseLeave={() => this.handleMouseUp()}\r\n                onContextMenu={(e) => e.preventDefault()}\r\n                onDragStart={(e) => e.preventDefault()}\r\n                >\r\n                    {Array.from(this.state.grid).map((row, rowIdx) => {\r\n                        return (\r\n                            <div key={rowIdx} className=\"grid-row\">\r\n                                {Array.from(row).map((node, nodeIdx) => {\r\n                                    const {row, col, cost, isStart, isTarget, isWall} = node;\r\n                                    return (\r\n                                        <Node\r\n                                        key={nodeIdx}\r\n                                        row={row}\r\n                                        col={col}\r\n                                        cost={cost}\r\n                                        isStart={isStart}\r\n                                        isTarget={isTarget}\r\n                                        isWall={isWall}\r\n                                        mousePressed={(row, col) => this.handleMouseDown(row, col)}\r\n                                        mouseEntered={(row, col) => this.handleMouseEnter(row, col)}\r\n                                        />\r\n                                    );\r\n                                })}\r\n                            </div>\r\n                        );\r\n                    })}\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default PathfindingVisualizer;","// Unsorted bar color\r\nconst UNSORTED = \"pink\";\r\n// Comparing bar color\r\nconst COMPARE = \"red\";\r\n// Sorted bar color\r\nconst SORTED = \"green\";\r\n// Swapping bar color\r\nconst SWAP = \"orange\";\r\n// Minimum bar color\r\nconst MIN = \"purple\";\r\n\r\n// Sorting algorithms\r\nexport const sortAlgorithms = {\r\n    SELECTION: \"selection\",\r\n    INSERTION: \"insertion\",\r\n    MERGE: \"merge\",\r\n}\r\n\r\n/**\r\n * Executes a Selection Sort on an array.\r\n * \r\n * @param {Array} array array of values\r\n * \r\n * @returns an array of animations\r\n */\r\nexport function selectionSort(array) {\r\n    const animations = [];\r\n\r\n    for (let i = 0; i < array.length; i++) {\r\n        var min = i;\r\n        animations.push([[MIN, min]]);\r\n        var newMin = true;\r\n        for (let k = i + 1; k < array.length; k++) {\r\n            if (newMin) {\r\n                animations.push([[COMPARE, k]]);\r\n                newMin = false;\r\n            } else animations.push([[UNSORTED, k-1], [COMPARE, k]]);\r\n            \r\n            if (array[min] > array[k]) {\r\n                animations.push([[UNSORTED, min], [MIN, k]]);\r\n                min = k;\r\n                newMin = true;\r\n            }\r\n        }\r\n        if (min !== i) {\r\n            animations.push([[UNSORTED, array.length-1], [SWAP, min, i], [null, min, array[i]], [null, i, array[min]]]);\r\n            animations.push([[UNSORTED, min], [SORTED, i]]);\r\n            var temp = array[i];\r\n            array[i] = array[min];\r\n            array[min] = temp;\r\n        } else animations.push([[UNSORTED, array.length-1], [SORTED, i]]);\r\n    }\r\n\r\n    return animations;\r\n}\r\n\r\n/**\r\n * Executes a Insertion Sort on an array.\r\n * \r\n * @param {Array} array array of values\r\n * \r\n * @returns an array of animations\r\n */\r\nexport function insertionSort(array) {\r\n    const animations = [];\r\n\r\n    for (let i = 1; i < array.length; i++) {\r\n        var cur = array[i];\r\n        var j = i - 1;\r\n        \r\n        animations.push([[COMPARE, j, i]]);\r\n        while (j >= 0) {\r\n            if (j + 2 >= array.length) animations.push([[COMPARE, j, j + 1]]);\r\n            else animations.push([[UNSORTED, j + 2], [COMPARE, j, j + 1]]);\r\n            if (array[j] <= cur) {\r\n                animations.push([[UNSORTED, j, j + 1]]);\r\n                break;\r\n            }\r\n            animations.push([[SWAP, j, j + 1], [null, j + 1, array[j]], [null, j, cur]]);\r\n            array[j + 1] = array[j];\r\n            j--;\r\n        }\r\n        if (j + 2 >= array.length) animations.push([[UNSORTED, j + 1]]);\r\n        else animations.push([[UNSORTED, j + 1, j + 2]]);\r\n        animations.push([[null, j + 1, cur]]);\r\n        array[j+1] = cur;\r\n    }\r\n    for (let i = array.length - 1; i >= 0; i--) animations.push([[SORTED, i]]);\r\n\r\n    return animations;\r\n}\r\n\r\n/**\r\n * Executes a Merge Sort on an array.\r\n * \r\n * @param {Array} array array of values\r\n * \r\n * @returns an array of animations\r\n */\r\nexport function mergeSort(array) {\r\n    const animations = [];\r\n    array = doMergeSort(animations, array);\r\n    return animations;\r\n}\r\n\r\n/**\r\n * Actual recursive Merge Sort function.\r\n * \r\n * @param {Array} animations array of animations\r\n * @param {Array} array array of values \r\n * \r\n * @returns sorted array\r\n */\r\nfunction doMergeSort(animations, array) {\r\n    const middle = array.length / 2;\r\n    if (array.length < 2) return array;\r\n    const left = array.splice(0, middle);\r\n    return merge(animations, doMergeSort(animations, left), doMergeSort(animations, array));\r\n}\r\n\r\n/**\r\n * Merge Sort helper function.\r\n * \r\n * @param {Array} animations array of animations\r\n * @param {Array} left left array\r\n * @param {Array} right right array\r\n * \r\n * @returns merged array\r\n */\r\nfunction merge (animations, left, right) {\r\n    var array = [];\r\n\r\n    while (left.length && right.length) {\r\n        if (left[0] < right[0]) array.push(left.shift());\r\n        else array.push(right.shift());\r\n    }\r\n    return [...array, ...left, ...right];\r\n}","import React from 'react';\r\nimport { Container, Row, Col, Button, ButtonDropdown, DropdownItem, DropdownToggle, DropdownMenu\r\n} from 'reactstrap';\r\n\r\nimport { sortAlgorithms } from './SortAlgorithms';\r\n\r\n/**\r\n * Represents the top menu of the sorting visualizer component.\r\n * \r\n * @author Jake Waclawski\r\n */\r\nclass SortMenu extends React.Component {\r\n    constructor (props) {\r\n        super(props);\r\n        // Visualize button dropdown status\r\n        this.state = { visualizeDropdownOpen: false };\r\n    }\r\n\r\n    /**\r\n     * Toggles the visualize button dropdown.\r\n     */\r\n    toggleVisualize () { this.setState({visualizeDropdownOpen: !this.state.visualizeDropdownOpen}); }\r\n \r\n    /**\r\n     * Renders the menu component.\r\n     * \r\n     * @returns a <div> element representing the menu\r\n     */\r\n    render () {\r\n        return (\r\n            <div className=\"sort-menu\">\r\n                <Container>\r\n                    <Row>\r\n                        <Col className=\"title\">\r\n                            Sorting Visualizer\r\n                        </Col>\r\n                        <Col>\r\n                            <Container>\r\n                                <Row>\r\n                                    <Col>\r\n                                        <ButtonDropdown isOpen={this.state.visualizeDropdownOpen} toggle={() => this.toggleVisualize()}>\r\n                                            <Button color=\"success\" onClick={() => this.toggleVisualize()}>Visualize</Button>\r\n                                            <DropdownToggle split color=\"success\" />\r\n                                            <DropdownMenu>\r\n                                                <DropdownItem onClick={() => this.props.sorter.visualizeSort(sortAlgorithms.SELECTION)}>Selection Sort</DropdownItem>\r\n                                                <DropdownItem onClick={() => this.props.sorter.visualizeSort(sortAlgorithms.INSERTION)}>Insertion Sort</DropdownItem>\r\n                                                <DropdownItem onClick={() => this.props.sorter.visualizeSort(sortAlgorithms.MERGE)}>Merge Sort</DropdownItem>\r\n                                            </DropdownMenu>\r\n                                        </ButtonDropdown>\r\n                                    </Col>\r\n                                    <Col>\r\n                                        <Button color=\"warning\" onClick={() => this.props.sorter.reGenerateArray()}>Randomize</Button>\r\n                                    </Col>\r\n                                </Row>\r\n                            </Container>\r\n                        </Col>\r\n                    </Row>\r\n                </Container>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default SortMenu;","import React from 'react';\r\n\r\nimport './SortingVisualizer.css';\r\n\r\nimport { random } from '../Utils';\r\nimport SortMenu from './SortMenu';\r\nimport { selectionSort, insertionSort, mergeSort, sortAlgorithms } from './SortAlgorithms';\r\n\r\n// Size of array\r\nconst ARRAY_SIZE = 100;\r\n// Minimum value in array\r\nconst MIN_VALUE = 5;\r\n// Maximum value in array\r\nconst MAX_VALUE = 500;\r\n// Speed between animations in miliseconds\r\nconst SPEED = 10;\r\n\r\n// Unsorted bar color\r\nconst UNSORTED = \"pink\";\r\n\r\n/**\r\n * Represents the sorting visualizer component.\r\n * \r\n * @author Jake Waclawski\r\n */\r\nclass SortingVisualizer extends React.Component {\r\n    constructor (props) {\r\n        super(props);\r\n        // Array of bar values\r\n        this.state = { array: [] };\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the array with new random values.\r\n     * \r\n     * @param {int} size size of array\r\n     * @param {int} min minimum value\r\n     * @param {int} max maximum value\r\n     */\r\n    rebuildArray (size, min, max) {\r\n        const array = [];\r\n        for (let i = 0; i < size; i++) { array.push(this.createBar(min, max)); }\r\n        return array;\r\n    }\r\n\r\n    /**\r\n     * Creates a new bar with a random value.\r\n     * \r\n     * @param {int} min lower bound of value\r\n     * @param {int} max upper bound of value\r\n     * \r\n     * @returns the created bar\r\n     */\r\n    createBar (min, max) { return random(min, max); }\r\n\r\n    /**\r\n     * Rebuilds the array and regenerates the visual array bars.\r\n     */\r\n    reGenerateArray () { \r\n        var array = this.state.array;\r\n        array = this.rebuildArray(ARRAY_SIZE, MIN_VALUE, MAX_VALUE);\r\n        const bars = document.getElementsByClassName(\"bar\");\r\n        for (let i = 0; i < array.length; i++) { bars[i].style.backgroundColor = UNSORTED; }\r\n        this.setState({array: array}); \r\n    }\r\n\r\n    /**\r\n     * Visualizes a given sorting algorithm.\r\n     * \r\n     * @param {sortAlgorithms} algorithm sorting algorithm\r\n     */\r\n    visualizeSort (algorithm) {\r\n        const array = this.state.array;\r\n        var animations = [];\r\n\r\n        switch (algorithm) {\r\n            case sortAlgorithms.SELECTION:\r\n                animations = selectionSort(array);\r\n                break;\r\n            case sortAlgorithms.INSERTION:\r\n                animations = insertionSort(array);\r\n                break;\r\n            case sortAlgorithms.MERGE:\r\n                animations = mergeSort(array);\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n\r\n        this.animateSort(animations);\r\n    }\r\n\r\n    /**\r\n     * Animates the process of the sorting algorithm. Iterates through an\r\n     * array of animation steps generated by the algorithm.\r\n     * \r\n     * @param {Array} animations \r\n     */\r\n    animateSort (animations) {\r\n        const bars = document.getElementsByClassName(\"bar\");\r\n        var i = 0\r\n        for (const step of animations) {\r\n            setTimeout(() => {\r\n                for (const action of step) { \r\n                    if (action[0] === null) {\r\n                        bars[action[1]].style.height = `${action[2]}px`;\r\n                    } else {\r\n                        for (let k = 1; k < action.length; k++) {\r\n                            bars[action[k]].style.backgroundColor = action[0]; \r\n                        }\r\n                    }\r\n                }\r\n            }, SPEED * i++);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Runs on page load. Rebuilds the array.\r\n     */\r\n    componentDidMount () {\r\n        const array = this.rebuildArray(ARRAY_SIZE, MIN_VALUE, MAX_VALUE);\r\n        this.setState({array: array});\r\n    }\r\n\r\n    /**\r\n     * Renders the sorting visualizer component.\r\n     * \r\n     * @returns a <div> element representing the component\r\n     */\r\n    render () {\r\n        //console.log(this.state.array);\r\n\r\n        return (\r\n            <div className=\"sort-vis\">\r\n                <div className=\"sort-menu\">\r\n                    <SortMenu sorter={this}/>\r\n                </div>\r\n                <div className=\"array\">\r\n                    {Array.from(this.state.array).map((bar, barIdx) => {\r\n                        return (\r\n                            <div className=\"bar\"\r\n                            key={barIdx}\r\n                            style={{\r\n                                backgroundColor: UNSORTED,\r\n                                height: `${bar}px`,\r\n                            }}/>\r\n                        );\r\n                    })}\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default SortingVisualizer;","import React from 'react';\r\nimport { Card, CardHeader, CardBody, NavItem, NavLink, Nav, TabContent, TabPane\r\n} from 'reactstrap'\r\nimport classnames from 'classnames';\r\n\r\nimport Home from './Home';\r\nimport PathfindingVisualizer from './PathfindingVisualizer/PathfindingVisualizer';\r\nimport SortingVisualizer from './SortingVisualizer/SortingVisualizer';\r\n\r\n// Default tab to display on page load\r\nconst DEFAULT_TAB = \"home\";\r\n\r\n/**\r\n * Represents the navigation bar at the top of the page. Each tab\r\n * contains one component of the project.\r\n * \r\n * @author Jake Waclawski\r\n */\r\nclass NavBar extends React.Component {\r\n    constructor (props) {\r\n        super(props);\r\n        // Current active tab\r\n        this.state = { activeTab: DEFAULT_TAB };\r\n    }\r\n\r\n    /**\r\n     * Renders the navigation bar.\r\n     * \r\n     * @returns a <div> element representing the navigation bar\r\n     */\r\n    render () {\r\n        return (\r\n            <div className=\"nav-bar\">\r\n                <Card>\r\n                    <CardHeader>\r\n                        <Nav tabs>\r\n                            <NavItem>\r\n                                <NavLink className={classnames({active: this.state.activeTab === \"home\"})}\r\n                                onClick={() => this.setState({activeTab: \"home\"})}\r\n                                >Home\r\n                                </NavLink>\r\n                            </NavItem>\r\n                            <NavItem>\r\n                                <NavLink className={classnames({active: this.state.activeTab === \"pathfind\"})}\r\n                                onClick={() => this.setState({activeTab: \"pathfind\"})}\r\n                                >Pathfinding Visualizer\r\n                                </NavLink>\r\n                            </NavItem>\r\n                            <NavItem>\r\n                                <NavLink className={classnames({active: this.state.activeTab === \"sort\"})}\r\n                                onClick={() => this.setState({activeTab: \"sort\"})}\r\n                                >Sorting Visualizer\r\n                                </NavLink>\r\n                            </NavItem>\r\n                        </Nav>\r\n                    </CardHeader>\r\n                    <CardBody>\r\n                        <TabContent activeTab={this.state.activeTab}>\r\n                            <TabPane tabId=\"home\">\r\n                                <Home />\r\n                            </TabPane>\r\n                            <TabPane tabId=\"pathfind\">\r\n                                <PathfindingVisualizer />\r\n                            </TabPane>\r\n                            <TabPane tabId=\"sort\">\r\n                                <SortingVisualizer />\r\n                            </TabPane>\r\n                        </TabContent>\r\n                    </CardBody>\r\n                </Card>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default NavBar;","import './App.css';\r\nimport NavBar from './NavBar';\r\n\r\nfunction App() {\r\n  return (\r\n    <div className=\"App\">\r\n      <NavBar></NavBar>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","const reportWebVitals = onPerfEntry => {\r\n  if (onPerfEntry && onPerfEntry instanceof Function) {\r\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\r\n      getCLS(onPerfEntry);\r\n      getFID(onPerfEntry);\r\n      getFCP(onPerfEntry);\r\n      getLCP(onPerfEntry);\r\n      getTTFB(onPerfEntry);\r\n    });\r\n  }\r\n};\r\n\r\nexport default reportWebVitals;\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport reportWebVitals from './reportWebVitals';\r\n\r\nimport 'bootstrap/dist/css/bootstrap.min.css';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n\r\n// If you want to start measuring performance in your app, pass a function\r\n// to log results (for example: reportWebVitals(console.log))\r\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\r\nreportWebVitals();\r\n"],"sourceRoot":""}