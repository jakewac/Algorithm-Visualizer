[{"C:\\Users\\mcjak\\Documents\\AlgoViz\\Algorithm-Visualizer\\src\\index.js":"1","C:\\Users\\mcjak\\Documents\\AlgoViz\\Algorithm-Visualizer\\src\\reportWebVitals.js":"2","C:\\Users\\mcjak\\Documents\\AlgoViz\\Algorithm-Visualizer\\src\\App.js":"3","C:\\Users\\mcjak\\Documents\\AlgoViz\\Algorithm-Visualizer\\src\\PathfindingVisualizer\\PathfindingVisualizer.js":"4","C:\\Users\\mcjak\\Documents\\AlgoViz\\Algorithm-Visualizer\\src\\SortingVisualizer\\SortingVisualizer.js":"5","C:\\Users\\mcjak\\Documents\\AlgoViz\\Algorithm-Visualizer\\src\\PathfindingVisualizer\\Grid\\Node.js":"6","C:\\Users\\mcjak\\Documents\\AlgoViz\\Algorithm-Visualizer\\src\\PathfindingVisualizer\\Menu\\PathfindMenu.js":"7","C:\\Users\\mcjak\\Documents\\AlgoViz\\Algorithm-Visualizer\\src\\PathfindingVisualizer\\Algorithms\\PathfindAlgorithms.js":"8","C:\\Users\\mcjak\\Documents\\AlgoViz\\Algorithm-Visualizer\\src\\PathfindingVisualizer\\Algorithms\\MazeAlgorithms.js":"9","C:\\Users\\mcjak\\Documents\\AlgoViz\\Algorithm-Visualizer\\src\\PathfindingVisualizer\\Menu\\PathfindStats.js":"10","C:\\Users\\mcjak\\Documents\\AlgoViz\\Algorithm-Visualizer\\src\\PathfindingVisualizer\\Menu\\NodeKey.js":"11","C:\\Users\\mcjak\\Documents\\AlgoViz\\Algorithm-Visualizer\\src\\SortingVisualizer\\Algorithms\\SortAlgorithms.js":"12","C:\\Users\\mcjak\\Documents\\AlgoViz\\Algorithm-Visualizer\\src\\SortingVisualizer\\Menu\\SortMenu.js":"13","C:\\Users\\mcjak\\Documents\\AlgoViz\\Algorithm-Visualizer\\src\\NavBar\\NavBar.js":"14","C:\\Users\\mcjak\\Documents\\AlgoViz\\Algorithm-Visualizer\\src\\PathfindingVisualizer\\Menu\\PVisualizerSettings.js":"15","C:\\Users\\mcjak\\Documents\\AlgoViz\\Algorithm-Visualizer\\src\\SortingVisualizer\\Menu\\SVisualizerSettings.js":"16","C:\\Users\\mcjak\\Documents\\AlgoViz\\Algorithm-Visualizer\\src\\Home\\Home.js":"17"},{"size":544,"mtime":1611339472778,"results":"18","hashOfConfig":"19"},{"size":375,"mtime":1610923586046,"results":"20","hashOfConfig":"19"},{"size":188,"mtime":1611293553591,"results":"21","hashOfConfig":"19"},{"size":29233,"mtime":1612153887040,"results":"22","hashOfConfig":"19"},{"size":4898,"mtime":1611975290484,"results":"23","hashOfConfig":"19"},{"size":1253,"mtime":1612028854880,"results":"24","hashOfConfig":"19"},{"size":904,"mtime":1611880224640,"results":"25","hashOfConfig":"19"},{"size":9469,"mtime":1612069756583,"results":"26","hashOfConfig":"19"},{"size":6152,"mtime":1612146999546,"results":"27","hashOfConfig":"19"},{"size":1186,"mtime":1611293970953,"results":"28","hashOfConfig":"19"},{"size":6683,"mtime":1612070771064,"results":"29","hashOfConfig":"19"},{"size":3945,"mtime":1611339490152,"results":"30","hashOfConfig":"19"},{"size":683,"mtime":1611339498131,"results":"31","hashOfConfig":"19"},{"size":3073,"mtime":1611621445928,"results":"32","hashOfConfig":"19"},{"size":10151,"mtime":1612144709232,"results":"33","hashOfConfig":"19"},{"size":5397,"mtime":1611466281999,"results":"34","hashOfConfig":"19"},{"size":1456,"mtime":1611601509367,"results":"35","hashOfConfig":"19"},{"filePath":"36","messages":"37","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},"1lhk93m",{"filePath":"39","messages":"40","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},{"filePath":"41","messages":"42","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},{"filePath":"43","messages":"44","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"45","messages":"46","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},{"filePath":"47","messages":"48","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},{"filePath":"49","messages":"50","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},{"filePath":"51","messages":"52","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"53","usedDeprecatedRules":"38"},{"filePath":"54","messages":"55","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"56","messages":"57","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},{"filePath":"58","messages":"59","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},{"filePath":"60","messages":"61","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},{"filePath":"62","messages":"63","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},{"filePath":"64","messages":"65","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},{"filePath":"66","messages":"67","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"68","messages":"69","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},{"filePath":"70","messages":"71","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},"C:\\Users\\mcjak\\Documents\\AlgoViz\\Algorithm-Visualizer\\src\\index.js",[],["72","73"],"C:\\Users\\mcjak\\Documents\\AlgoViz\\Algorithm-Visualizer\\src\\reportWebVitals.js",[],"C:\\Users\\mcjak\\Documents\\AlgoViz\\Algorithm-Visualizer\\src\\App.js",[],"C:\\Users\\mcjak\\Documents\\AlgoViz\\Algorithm-Visualizer\\src\\PathfindingVisualizer\\PathfindingVisualizer.js",[],"C:\\Users\\mcjak\\Documents\\AlgoViz\\Algorithm-Visualizer\\src\\SortingVisualizer\\SortingVisualizer.js",[],"C:\\Users\\mcjak\\Documents\\AlgoViz\\Algorithm-Visualizer\\src\\PathfindingVisualizer\\Grid\\Node.js",[],"C:\\Users\\mcjak\\Documents\\AlgoViz\\Algorithm-Visualizer\\src\\PathfindingVisualizer\\Menu\\PathfindMenu.js",[],"C:\\Users\\mcjak\\Documents\\AlgoViz\\Algorithm-Visualizer\\src\\PathfindingVisualizer\\Algorithms\\PathfindAlgorithms.js",["74"],"// Pathfinding algorithms\r\nexport const pathfindAlgorithms = {\r\n    DIJKSTRA: \"Dijkstra\",\r\n    ASTAR: \"A* (A-Star)\",\r\n    BFS: \"Breadth First Search\",\r\n    DFS: \"Depth First Search\",\r\n    DEV: \"Development Algorithm\",\r\n}\r\n\r\nfunction heuristic(cur, start, target, diagonalNeighbors) {\r\n    let dMultiplier = parseInt(document.getElementById(\"ns-dmultiplier\").value);\r\n    \r\n    const diagCost = Math.sqrt(2);\r\n    if (!dMultiplier) dMultiplier = 1;\r\n\r\n    const rowDistance = Math.abs(target.row - cur.row);\r\n    const colDistance = Math.abs(target.col - cur.col);\r\n\r\n    const startRowDistance = Math.abs(target.row - start.row);\r\n    const startColDistance = Math.abs(target.col - start.col);\r\n\r\n    const cross = Math.abs(colDistance * startRowDistance - startColDistance * rowDistance);\r\n\r\n    const manhattanD = dMultiplier * (rowDistance + colDistance);\r\n\r\n    const diagonalD = dMultiplier * (rowDistance + colDistance) + (diagCost - 2 * dMultiplier) * Math.min(rowDistance, colDistance);\r\n\r\n    const directRoute = Math.sqrt(rowDistance**2 + colDistance**2);\r\n\r\n    let heuristic = diagonalNeighbors ? diagonalD : manhattanD;\r\n\r\n    heuristic += (cross * 0.001);\r\n\r\n    return heuristic;\r\n}\r\n\r\nexport function devAlg(grid, start, target, diagonalNeighbors) {\r\n    \r\n}\r\n\r\n/**\r\n * Executes a Dijkstra's algorithm search.\r\n * \r\n * @param {Array} grid grid of nodes\r\n * @param {Object} start start node\r\n * @param {Object} target target node\r\n * \r\n * @returns an array of visited nodes in order\r\n */\r\nexport function dijkstra(grid, start, target, diagonalNeighbors) {\r\n    const visitedNodes = [];\r\n    const unvisitedNodes = getAllNodes(grid);\r\n\r\n    for (const node of getAllNodes(grid)) node.distance = Infinity;\r\n    start.distance = 0;\r\n\r\n    while (unvisitedNodes.length !== 0) {\r\n        unvisitedNodes.sort((a, b) => a.distance - b.distance);\r\n        const curNode = unvisitedNodes.shift();\r\n\r\n        if (curNode.isVisited || curNode.isWall) continue;\r\n        if (curNode === target || curNode.distance === Infinity) return visitedNodes;\r\n\r\n        const unvisitedNeighbors = getUnvisitedNeighbors(curNode, grid, diagonalNeighbors);\r\n        for (const neighbor of unvisitedNeighbors) {\r\n            var neighborCost = neighbor.cost;\r\n\r\n            const diagCost = Math.sqrt(2) - 1;\r\n            if (neighbor.isDiagonal) neighborCost += diagCost;\r\n            neighbor.isDiagonal = false;\r\n\r\n            const tentativeDistance = curNode.distance + neighborCost;\r\n            if (neighbor.distance > tentativeDistance) {\r\n                neighbor.previousNode = curNode;\r\n                neighbor.distance = tentativeDistance;\r\n            }\r\n        }\r\n\r\n        curNode.isVisited = true;\r\n        visitedNodes.push(curNode);\r\n    }\r\n\r\n    return visitedNodes;\r\n}\r\n\r\n/**\r\n * Executes an A* (A-Star) algorithm search.\r\n * \r\n * @param {Array} grid grid of nodes\r\n * @param {Object} start start node\r\n * @param {Object} target target node\r\n * \r\n * @returns an array of visited nodes in order\r\n */\r\nexport function aStar(grid, start, target, diagonalNeighbors) {\r\n    const visitedNodes = [];\r\n    const unvisitedNodes = [];\r\n\r\n    for (const node of getAllNodes(grid)) {\r\n        node.startCost = Infinity;\r\n        node.finalCost = Infinity;\r\n    }\r\n    start.startCost = 0;\r\n    start.finalCost = heuristic(start, start, target, diagonalNeighbors);\r\n    unvisitedNodes.push(start);\r\n\r\n    while (unvisitedNodes.length !== 0) {\r\n        unvisitedNodes.sort((a, b) => a.finalCost - b.finalCost);\r\n        const curNode = unvisitedNodes.shift();\r\n\r\n        if (curNode.isVisited || curNode.isWall) continue;\r\n        if (curNode === target) return visitedNodes;\r\n\r\n        const unvisitedNeighbors = getUnvisitedNeighbors(curNode, grid, diagonalNeighbors);\r\n        for (const neighbor of unvisitedNeighbors) {\r\n            var neighborCost = neighbor.cost\r\n            const diagCost = Math.sqrt(2) - 1;\r\n            if (neighbor.isDiagonal) neighborCost += diagCost;\r\n            neighbor.isDiagonal = false;\r\n            \r\n            const tentativeStartCost = curNode.startCost + neighborCost;\r\n            \r\n            if (tentativeStartCost < neighbor.startCost) {\r\n                neighbor.previousNode = curNode;\r\n\r\n                neighbor.startCost = tentativeStartCost;\r\n                neighbor.finalCost = neighbor.startCost + heuristic(neighbor, start, target, diagonalNeighbors);\r\n\r\n                if (!unvisitedNodes.includes(neighbor)) unvisitedNodes.push(neighbor);\r\n            }\r\n        }\r\n\r\n        curNode.isVisited = true;\r\n        visitedNodes.push(curNode);\r\n    }\r\n\r\n    return visitedNodes;\r\n}\r\n\r\n/**\r\n * Executes Breadth First Search (BFS) algorithm search.\r\n * \r\n * @param {Array} grid grid of nodes\r\n * @param {Object} start start node\r\n * @param {Object} target target node\r\n * \r\n * @returns an array of visited nodes in order\r\n */\r\nexport function breadthFirstSearch(grid, start, target, diagonalNeighbors) {\r\n    const visitedNodes = [];\r\n    const unvisitedNodes = [start];\r\n    start.distance = 0;\r\n   \r\n    while (unvisitedNodes.length !== 0) {\r\n        const curNode = unvisitedNodes.shift();\r\n\r\n        if (curNode.isVisited || curNode.isWall) continue;\r\n        if (curNode === target || curNode.distance === Infinity) return visitedNodes; \r\n\r\n        const unvisitedNeighbors = getUnvisitedNeighbors(curNode, grid, diagonalNeighbors);\r\n        for (const neighbor of unvisitedNeighbors) {\r\n            unvisitedNodes.push(neighbor);\r\n            neighbor.previousNode = curNode;\r\n            neighbor.distance = curNode.distance + 1;\r\n        }\r\n\r\n        curNode.isVisited = true;\r\n        visitedNodes.push(curNode);\r\n    }\r\n    return visitedNodes;\r\n}\r\n\r\n/**\r\n * Executes a Depth First Search (DFS) algorithm search.\r\n * \r\n * @param {Array} grid grid of nodes\r\n * @param {Object} start start node\r\n * @param {Object} target target node\r\n * \r\n * @returns an array of visited nodes in order\r\n */\r\nexport function depthFirstSearch(grid, start, target, diagonalNeighbors) {\r\n    const visitedNodes = [];\r\n    const unvisitedNodes = [start];\r\n    \r\n    while (unvisitedNodes.length !== 0) {\r\n        const curNode = unvisitedNodes.pop();\r\n\r\n        if (curNode.isWall || curNode.isVisited) continue;\r\n        if (curNode === target) return visitedNodes;\r\n\r\n        const unvisitedNeighbors = getUnvisitedNeighbors(curNode, grid, diagonalNeighbors);\r\n        for (const neighbor of unvisitedNeighbors) {\r\n            unvisitedNodes.push(neighbor);\r\n            neighbor.previousNode = curNode;\r\n        }\r\n\r\n        curNode.isVisited = true;\r\n        visitedNodes.push(curNode);\r\n    }\r\n    return visitedNodes;\r\n}\r\n\r\n/**\r\n * Gets all of the nodes in the grid.\r\n * \r\n * @param {Array} grid grid of nodes\r\n * \r\n * @returns an array containing all of the nodes\r\n */\r\nfunction getAllNodes(grid) {\r\n    const nodes = [];\r\n    for (const row of grid) {\r\n        for (const node of row) nodes.push(node);\r\n    }\r\n    return nodes;\r\n}\r\n\r\n/**\r\n * Gets the shortest path of nodes from the target node to \r\n * the start node.\r\n * \r\n * @param {Object} targetNode target node\r\n * \r\n * @returns an array of shortest path nodes in order\r\n */\r\nexport function getShortestPathNodes(targetNode) {\r\n    const nodesInShortestPath = [];\r\n    let currentNode = targetNode;\r\n    while (currentNode !== null) {\r\n        nodesInShortestPath.unshift(currentNode);\r\n        currentNode = currentNode.previousNode;\r\n    }\r\n    return nodesInShortestPath;\r\n}\r\n\r\n/**\r\n * Gets the total weighted cost of the shortest path.\r\n * \r\n * @param {Object} targetNode target node\r\n * \r\n * @returns the total cost\r\n */\r\nexport function getShortestPathCost(targetNode) {\r\n    const nodesInShortestPath = [];\r\n    let currentNode = targetNode;\r\n    let totalCost = 0;\r\n    while (currentNode !== null) {\r\n        nodesInShortestPath.unshift(currentNode);\r\n        totalCost += currentNode.cost;\r\n        currentNode = currentNode.previousNode;\r\n    }\r\n    return totalCost;\r\n}\r\n\r\n/**\r\n * Gets all unvisited neighbors of a given node.\r\n * \r\n * @param {Object} node node\r\n * @param {Array} grid grid of nodes\r\n * @param {boolean} diagonals are we allowing diagonal neighbors\r\n * \r\n * @returns an array containing all unvisited neighbors\r\n */\r\nfunction getUnvisitedNeighbors(node, grid, diagonals) {\r\n    const neighbors = [];\r\n    const {row, col} = node;\r\n    \r\n    if (diagonals && row > 0 && col > 0) {\r\n        neighbors.push(grid[row - 1][col - 1]); // North West    \r\n        grid[row - 1][col - 1].isDiagonal = true;;\r\n    }\r\n\r\n    if (col > 0) neighbors.push(grid[row][col - 1]); // West\r\n\r\n    if (diagonals && row < grid.length - 1 && col > 0) {\r\n        neighbors.push(grid[row + 1][col - 1]); // South West\r\n        grid[row + 1][col - 1].isDiagonal = true;;\r\n    }\r\n\r\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]); // South\r\n\r\n    if (diagonals && row < grid.length - 1 && col < grid[row].length - 1) {\r\n        neighbors.push(grid[row + 1][col + 1]); // South East\r\n        grid[row + 1][col + 1].isDiagonal = true;;\r\n    }\r\n\r\n    if (col < grid[row].length - 1) neighbors.push(grid[row][col + 1]); // East\r\n\r\n    if (diagonals && row > 0 && col < grid[row].length - 1) {\r\n        neighbors.push(grid[row - 1][col + 1]); // North East\r\n        grid[row - 1][col + 1].isDiagonal = true;;\r\n    }\r\n\r\n    if (row > 0) neighbors.push(grid[row - 1][col]); // North\r\n\r\n    return neighbors.filter(neighbor => !neighbor.isVisited);\r\n}","C:\\Users\\mcjak\\Documents\\AlgoViz\\Algorithm-Visualizer\\src\\PathfindingVisualizer\\Algorithms\\MazeAlgorithms.js",[],"C:\\Users\\mcjak\\Documents\\AlgoViz\\Algorithm-Visualizer\\src\\PathfindingVisualizer\\Menu\\PathfindStats.js",[],"C:\\Users\\mcjak\\Documents\\AlgoViz\\Algorithm-Visualizer\\src\\PathfindingVisualizer\\Menu\\NodeKey.js",[],"C:\\Users\\mcjak\\Documents\\AlgoViz\\Algorithm-Visualizer\\src\\SortingVisualizer\\Algorithms\\SortAlgorithms.js",[],"C:\\Users\\mcjak\\Documents\\AlgoViz\\Algorithm-Visualizer\\src\\SortingVisualizer\\Menu\\SortMenu.js",[],"C:\\Users\\mcjak\\Documents\\AlgoViz\\Algorithm-Visualizer\\src\\NavBar\\NavBar.js",[],"C:\\Users\\mcjak\\Documents\\AlgoViz\\Algorithm-Visualizer\\src\\PathfindingVisualizer\\Menu\\PVisualizerSettings.js",[],"C:\\Users\\mcjak\\Documents\\AlgoViz\\Algorithm-Visualizer\\src\\SortingVisualizer\\Menu\\SVisualizerSettings.js",[],"C:\\Users\\mcjak\\Documents\\AlgoViz\\Algorithm-Visualizer\\src\\Home\\Home.js",[],{"ruleId":"75","replacedBy":"76"},{"ruleId":"77","replacedBy":"78"},{"ruleId":"79","severity":1,"message":"80","line":28,"column":11,"nodeType":"81","messageId":"82","endLine":28,"endColumn":22},"no-native-reassign",["83"],"no-negated-in-lhs",["84"],"no-unused-vars","'directRoute' is assigned a value but never used.","Identifier","unusedVar","no-global-assign","no-unsafe-negation"]